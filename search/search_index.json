{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to RISK Documentation","text":"<p>RISK (Regional Inference of Significant Kinships) is a modular, scalable tool for biological network annotation and visualization. It combines community detection, rigorous statistical testing, and high-resolution visualization to resolve functional modules and uncover biologically meaningful relationships. RISK scales efficiently to large networks, adapts across diverse data types, and produces publication-ready figures.</p> <p> RISK workflow overview and analysis of the Saccharomyces cerevisiae protein\u2013protein interaction (PPI) network. RISK identifies biologically coherent modules overrepresented in Gene Ontology Biological Process (GO BP; Ashburner et al., 2000), highlighting cellular organization such as ribosomal assembly, mitochondrial organization, and RNA polymerase activity (P &lt; 0.0001).</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Begin here for setup and core concepts:</p> <ul> <li>0. Introduction: Overview of RISK and key principles</li> <li>1. Installation: Install RISK on your system</li> </ul> <p>Interactive tutorials:</p> <ul> <li>Launch Quickstart in Binder (no installation required)</li> <li>Full Tutorial (HTML)</li> <li>Download Tutorial + Data (ZIP)</li> </ul>"},{"location":"#core-features","title":"Core Features","text":"<ul> <li>2. Network Input</li> <li>3. Annotation Input</li> <li>4. Clustering &amp; Statistics</li> <li>5. Analyzing Results</li> <li>6. Visualization</li> <li>7. Analysis Parameters</li> </ul> <p>For interactive examples, use tutorial.zip in Jupyter or view the static HTML version.</p> <p>Contributions are welcome on GitHub. Explore the RISK source code.</p>"},{"location":"0_introduction/","title":"Introduction to RISK","text":"<p>RISK (Regional Inference of Significant Kinships) is a next-generation tool for biological network annotation and visualization. It integrates community detection algorithms, statistically rigorous overrepresentation analysis, and high-resolution visualization to uncover structured relationships in complex networks.</p> <p>RISK is designed to:</p> <ul> <li>Identify biologically coherent modules in large-scale networks</li> <li>Perform fast and flexible overrepresentation testing</li> <li>Generate publication-ready visualizations</li> <li>Scale to networks with hundreds of thousands of edges on standard hardware</li> <li>Generalize beyond biology to interdisciplinary networks</li> </ul>"},{"location":"0_introduction/#risk-features","title":"RISK Features","text":"Category Capabilities Clustering Louvain, Leiden, Markov Clustering, Spinglass, Walktrap, Greedy Modularity, Label Propagation Statistical Tests Permutation, Hypergeometric, Chi-squared, Binomial Network Formats Cytoscape, Cytoscape JSON, GPickle, NetworkX Annotation Formats JSON, CSV, TSV, Excel, Python dictionary Scalability Efficient analysis of networks with 500k+ edges on standard hardware Visualization High-resolution outputs (SVG, PNG, PDF) Cross-domain Use Demonstrated on physics citation networks (Supplementary Fig. S7)"},{"location":"0_introduction/#example-applications","title":"Example Applications","text":"<ul> <li>Functional module identification in S. cerevisiae PPI and GI networks</li> <li>Chemical\u2013genetic interaction (Chem-GI) mapping to infer compound targets</li> <li>Microbial interaction networks to reveal host\u2013pathogen relationships</li> <li>Cross-domain application to non-biological networks (e.g., physics citation networks)</li> </ul>"},{"location":"0_introduction/#interactive-examples","title":"Interactive Examples","text":"<p>For a complete workflow, see tutorial.html, which demonstrates all key steps\u2014from loading a network to generating publication-ready figures\u2014in a single notebook. You can also download the notebook and data as a ZIP.</p> <p>The tutorial applies RISK to the Saccharomyces cerevisiae protein\u2013protein interaction (PPI) network (3,839 nodes, 30,955 edges; Michaelis et al., 2023). It illustrates:</p> <ul> <li>Network clustering and module detection</li> <li>Annotation-based overrepresentation analysis</li> <li>Advanced visualization and interactive exploration</li> <li>Parameter export and reproducibility tools</li> </ul> <p>This notebook complements this documentation\u2014use it for end-to-end examples and contextual guidance.</p> <p>You can also launch the Quickstart notebook on Binder for an interactive session without local installation.</p>"},{"location":"0_introduction/#next-step","title":"Next Step","text":"<p>Installation and Setup</p>"},{"location":"1_installation/","title":"Installation and Setup","text":"<p>RISK is available on PyPI and supports Python 3.8 or later on major operating systems (Windows, macOS, Linux). Install the latest release with:</p> <pre><code>pip install risk-network --upgrade\n</code></pre> <p>To install from source:</p> <pre><code>git clone https://github.com/riskportal/risk.git\ncd network\npip install .\npip install -e .  # for editable/development install\n</code></pre>"},{"location":"1_installation/#importing-risk","title":"Importing RISK","text":"<p>Verify the installation and import the package:</p> <pre><code>import risk as r\nprint(f\"RISK version: {r.__version__}\")\n</code></pre> <p>The core functionality is accessed through the <code>RISK</code> class:</p> <pre><code>from risk import RISK\n</code></pre> <p>For Jupyter notebooks, enable inline plotting:</p> <pre><code>%matplotlib inline\n</code></pre>"},{"location":"1_installation/#initializing-risk","title":"Initializing RISK","text":"<p><code>RISK</code> provides modular access to clustering, statistics, and visualization components. Initialize it to start analysis:</p> <p>Parameters:</p> <ul> <li><code>verbose</code> (bool): Controls whether log messages are printed. If <code>True</code>, log messages are printed to the console. Defaults to True.</li> </ul> <pre><code>risk = RISK(verbose=True)\n</code></pre>"},{"location":"1_installation/#next-step","title":"Next Step","text":"<p>Loading Networks into RISK</p>"},{"location":"2_network_input/","title":"Loading Networks into RISK","text":"<p>Networks form the foundation of any RISK analysis, representing nodes (e.g., genes, proteins, papers) and the edges, or relationships, connecting them.</p> <p>RISK provides flexible loading functions compatible with multiple formats\u2014including Cytoscape session files, Cytoscape JSON exports, GPickle files, and in-memory NetworkX graphs. These loaders standardize input into NetworkX graph objects ready for downstream analysis, with options for preprocessing such as spherical projection, surface depth adjustment, and node filtering.</p>"},{"location":"2_network_input/#supported-input-formats","title":"Supported Input Formats","text":"Format Method Description <code>.cys</code> <code>load_network_cytoscape()</code> Load from Cytoscape session files; supports source/target labels and optional view selection. <code>.cyjs</code> <code>load_network_cyjs()</code> Import Cytoscape JSON format; specify source and target labels for nodes and edges. <code>.gpickle</code> <code>load_network_gpickle()</code> Reload serialized NetworkX graphs; preserves full network structure. <code>NetworkX</code> <code>load_network_networkx()</code> Convert an existing NetworkX graph object into a RISK-compatible format."},{"location":"2_network_input/#shared-parameters","title":"Shared Parameters","text":"<p>Shared parameters among network loaders.</p> <ul> <li><code>compute_sphere</code> (bool, optional): Whether to map nodes from a 2D plane onto a 3D spherical surface using a spherical projection. Defaults to True.</li> <li><code>surface_depth</code> (float, optional): Adjusts the depth of nodes relative to the spherical surface, enhancing visualization of clustering. Defaults to 0.0.</li> <li><code>min_edges_per_node</code> (int, optional): Minimum number of edges per node. Values &gt;0 prune nodes with fewer edges. Defaults to 0.</li> </ul>"},{"location":"2_network_input/#cytoscape-cys-files","title":"Cytoscape <code>.cys</code> Files","text":"<p>Load Cytoscape session files exported from the desktop app.</p> <p>Additional Parameters:</p> <ul> <li><code>filepath</code> (str): Path to the Cytoscape file.</li> <li><code>source_label</code> (str, optional): Source node label. Defaults to \"source\".</li> <li><code>target_label</code> (str, optional): Target node label. Defaults to \"target\".</li> <li><code>view_name</code> (str, optional): Specific view name to load. Defaults to \"\".</li> </ul> <p>Returns: <code>nx.Graph</code>: The loaded and processed network as a NetworkX graph.</p> <pre><code>network = risk.load_network_cytoscape(\n    filepath=\"./data/cytoscape/michaelis_2023.cys\",\n    source_label=\"source\",\n    target_label=\"target\",\n    view_name=\"\",\n    compute_sphere=True,\n    surface_depth=0.0,\n    min_edges_per_node=0,\n)\n</code></pre>"},{"location":"2_network_input/#cytoscape-json-cyjs-files","title":"Cytoscape JSON (<code>.cyjs</code>) Files","text":"<p>Load JSON exports from Cytoscape Web or JavaScript pipelines.</p> <p>Additional Parameters:</p> <ul> <li><code>filepath</code> (str): Path to the Cytoscape JSON file.</li> <li><code>source_label</code> (str, optional): Source node label. Defaults to \"source\".</li> <li><code>target_label</code> (str, optional): Target node label. Defaults to \"target\".</li> </ul> <p>Returns: <code>nx.Graph</code>: The loaded and processed network as a NetworkX graph.</p> <pre><code>network = risk.load_network_cyjs(\n    filepath=\"./data/cyjs/michaelis_2023.cyjs\",\n    source_label=\"source\",\n    target_label=\"target\",\n    compute_sphere=True,\n    surface_depth=0.1,\n    min_edges_per_node=1,\n)\n</code></pre>"},{"location":"2_network_input/#gpickle-gpickle-files","title":"GPickle (<code>.gpickle</code>) Files","text":"<p>Fast, Python-native serialization of NetworkX graphs preserving all attributes. Recommended for reproducibility and performance.</p> <p>Additional Parameters:</p> <ul> <li><code>filepath</code> (str): Path to the GPickle file.</li> </ul> <p>Returns: <code>nx.Graph</code>: The loaded and processed network as a NetworkX graph.</p> <pre><code>network = risk.load_network_gpickle(\n    filepath=\"./data/gpickle/michaelis_2023.gpickle\",\n    compute_sphere=True,\n    surface_depth=0.1,\n    min_edges_per_node=1,\n)\n</code></pre>"},{"location":"2_network_input/#networkx-graphs","title":"NetworkX Graphs","text":"<p>Load from an in-memory <code>networkx.Graph</code>. Integrates seamlessly when the graph is already loaded.</p> <p>Additional Parameters:</p> <ul> <li><code>network</code> (nx.Graph): A NetworkX graph object.</li> </ul> <p>Returns: <code>nx.Graph</code>: The loaded and processed network as a NetworkX graph.</p> <pre><code>network = risk.load_network_networkx(\n    network=network,\n    compute_sphere=True,\n    surface_depth=0.1,\n    min_edges_per_node=1,\n)\n</code></pre>"},{"location":"2_network_input/#next-step","title":"Next Step","text":"<p>Loading Annotations into RISK</p>"},{"location":"3_annotation_input/","title":"Loading Annotations into RISK","text":"<p>Annotations provide the biological context for RISK by linking network clusters to functional terms (e.g., cellular components, metabolic pathways, protein complexes). They enable downstream statistical tests to evaluate whether specific functions are overrepresented within detected network clusters.</p> <p>Annotations must be provided by the user and formatted clearly to ensure compatibility with RISK loaders. RISK does not bundle annotations; users should obtain curated resources and format them as term\u2013to\u2013node (e.g., genes/proteins) membership tables. Common sources include:</p> <ul> <li>Gene Ontology (GO) (Ashburner et al., 2000)</li> <li>CORUM: Comprehensive Resource of Mammalian Protein Complexes (Tsitsiridis et al., 2022)</li> <li>KEGG: Kyoto Encyclopedia of Genes and Genomes (Kanehisa et al., 2023)</li> </ul> <p>These resources provide standardized annotation files (e.g., GAF, GMT, tab-delimited) that can be adapted into RISK\u2019s required format.</p> <p>RISK expects annotations in a simple term\u2013to\u2013node mapping, such as a JSON/dictionary.  For example:</p> <pre><code>{\n  \"proline biosynthetic process\": [\"CAR2\", \"PRO1\", \"PRO2\", \"PRO3\", \"YHR033W\"],\n  \"glyoxylate metabolic process\": [\n    \"DAL7\",\n    \"GOR1\",\n    \"ICL1\",\n    \"IDP1\",\n    \"IDP2\",\n    \"IDP3\",\n    \"LEU2\",\n    \"MDH3\",\n    \"MLS1\"\n  ]\n}\n</code></pre>"},{"location":"3_annotation_input/#supported-input-formats","title":"Supported Input Formats","text":"<p>Node IDs must match the network\u2019s node labels; unmapped IDs are ignored. Terms may overlap, and a node can belong to multiple terms. Terms outside <code>min_nodes_per_term</code> and <code>max_nodes_per_term</code> are filtered.</p> Format Method Description <code>.json</code> <code>load_annotation_json()</code> Import annotations from a JSON file. <code>.csv</code> <code>load_annotation_csv()</code> Import from a CSV file (supports delimiter). <code>.tsv</code> <code>load_annotation_tsv()</code> Import from a tab-separated file. <code>.xlsx</code>/<code>.xls</code> <code>load_annotation_excel()</code> Import from a specified Excel sheet. <code>dict</code> <code>load_annotation_dict()</code> Load annotations from a Python dictionary in memory."},{"location":"3_annotation_input/#shared-parameters","title":"Shared Parameters","text":"<p>Shared parameters among annotation loaders.</p> <ul> <li><code>network</code> (nx.Graph): The network to which the annotation is related.</li> <li><code>min_nodes_per_term</code> (int, optional): The minimum number of network nodes required for each annotation term to be included. Defaults to 1.</li> <li><code>max_nodes_per_term</code> (int, optional): The maximum number of network nodes required for each annotation term to be included. Defaults to 10_000.</li> </ul>"},{"location":"3_annotation_input/#json-annotation","title":"JSON Annotation","text":"<p>Load annotation data from a JSON file and associate terms with network nodes.</p> <p>Additional Parameters:</p> <ul> <li><code>filepath</code> (str): Path to the JSON annotation file.</li> </ul> <p>Returns: <code>dict</code>: A dictionary containing ordered nodes, ordered annotations, and the annotation matrix.</p> <pre><code>annotation = risk.load_annotation_json(\n    network=network,\n    filepath=\"./data/json/annotation/go_biological_process.json\",\n    min_nodes_per_term=1,\n    max_nodes_per_term=10_000,\n)\n</code></pre>"},{"location":"3_annotation_input/#csv-annotation","title":"CSV Annotation","text":"<p>Load annotation data from a CSV file, specifying columns and delimiter for nodes.</p> <p>Additional Parameters:</p> <ul> <li><code>filepath</code> (str): Path to the CSV annotation file.</li> <li><code>label_colname</code> (str): Name of the column containing the annotation term (e.g., GO term).</li> <li><code>nodes_colname</code> (str): Name of the column containing the nodes associated with each label.</li> <li><code>nodes_delimiter</code> (str, optional): Delimiter used to separate multiple nodes within the nodes column. Defaults to ';'.</li> </ul> <p>Returns: <code>dict</code>: A dictionary containing ordered nodes, ordered annotations, and the annotation matrix.</p> <pre><code>annotation = risk.load_annotation_csv(\n    network=network,\n    filepath=\"./data/csv/annotation/go_biological_process.csv\",\n    label_colname=\"label\",\n    nodes_colname=\"nodes\",\n    nodes_delimiter=\";\",\n    min_nodes_per_term=1,\n    max_nodes_per_term=10_000,\n)\n</code></pre>"},{"location":"3_annotation_input/#tsv-annotation","title":"TSV Annotation","text":"<p>Load annotation data from a tab-delimited file, similar to CSV but with tabs as separators.</p> <p>Additional Parameters:</p> <ul> <li><code>filepath</code> (str): Path to the TSV annotation file.</li> <li><code>label_colname</code> (str): Name of the column containing the annotation term (e.g., GO term).</li> <li><code>nodes_colname</code> (str): Name of the column containing the nodes associated with each label.</li> <li><code>nodes_delimiter</code> (str, optional): Delimiter used to separate multiple nodes within the nodes column. Defaults to ';'.</li> </ul> <p>Returns: <code>dict</code>: A dictionary containing ordered nodes, ordered annotations, and the annotation matrix.</p> <pre><code>annotation = risk.load_annotation_tsv(\n    network=network,\n    filepath=\"./data/tsv/annotation/go_biological_process.tsv\",\n    label_colname=\"label\",\n    nodes_colname=\"nodes\",\n    nodes_delimiter=\";\",\n    min_nodes_per_term=1,\n    max_nodes_per_term=10_000,\n)\n</code></pre>"},{"location":"3_annotation_input/#excel-annotation","title":"Excel Annotation","text":"<p>Load annotation data from an Excel workbook, with support for selecting specific sheets.</p> <p>Additional Parameters:</p> <ul> <li><code>filepath</code> (str): Path to the Excel annotation file.</li> <li><code>label_colname</code> (str): Name of the column containing the annotation term (e.g., GO term).</li> <li><code>nodes_colname</code> (str): Name of the column containing the nodes associated with each label.</li> <li><code>sheet_name</code> (str, optional): The name of the Excel sheet to load. Defaults to 'Sheet1'.</li> <li><code>nodes_delimiter</code> (str, optional): Delimiter used to separate multiple nodes within the nodes column. Defaults to ';'.</li> </ul> <p>Returns: <code>dict</code>: A dictionary containing ordered nodes, ordered annotations, and the annotation matrix.</p> <pre><code>annotation = risk.load_annotation_excel(\n    network=network,\n    filepath=\"./data/excel/annotation/go_biological_process.xlsx\",\n    label_colname=\"label\",\n    nodes_colname=\"nodes\",\n    sheet_name=\"Sheet1\",\n    nodes_delimiter=\";\",\n    min_nodes_per_term=1,\n    max_nodes_per_term=10_000,\n)\n</code></pre>"},{"location":"3_annotation_input/#dictionary-based-annotation","title":"Dictionary-Based Annotation","text":"<p>Load annotation data already in memory as a Python dictionary.</p> <p>Additional Parameters:</p> <ul> <li><code>content</code> (dict): The annotation dictionary to load.</li> </ul> <p>Returns: <code>dict</code>: A dictionary containing ordered nodes, ordered annotations, and the annotation matrix.</p> <pre><code>import json\n\nwith open(\"./data/json/annotation/go_biological_process.json\") as file:\n    annotation_dict = json.load(file)\n\nannotation = risk.load_annotation_dict(\n    network=network,\n    content=annotation_dict,\n    min_nodes_per_term=1,\n    max_nodes_per_term=10_000,\n)\n</code></pre>"},{"location":"3_annotation_input/#next-step","title":"Next Step","text":"<p>Clustering Algorithms and Statistical Methods</p>"},{"location":"4_clustering_statistics/","title":"Clustering Algorithms and Statistical Methods","text":"<p>Clustering algorithms detect structured regions of varying size and compactness, while statistical methods evaluate overrepresentation of biological terms within these regions. The choice of algorithm or test depends on network scale, density, and biological context, influencing the resolution, granularity, and rigor of the resulting modules and overrepresentation results.</p>"},{"location":"4_clustering_statistics/#summary-of-clustering-algorithms","title":"Summary of Clustering Algorithms","text":"<p>Before applying statistical tests, RISK groups nodes into modules using community detection. Each algorithm has strengths for different network sizes and contexts.</p> Algorithm Speed Primary use When/Why (assumptions &amp; notes) Louvain Fast Default, scalable to very large networks Greedy modularity optimization (Blondel et al., 2008); efficient for &gt;10\u2074 nodes; may produce disconnected subclusters. Leiden Fast Improved Louvain with better resolution Guarantees well-connected communities; more stable than Louvain (Traag et al., 2019); slightly higher runtime. Markov Clustering Medium Detect smaller, compact complexes Flow-based algorithm (Van Dongen, 2008); good for protein complexes or tightly connected submodules. Walktrap Medium Hierarchical detection in mid-sized graphs Random-walk based (Pons &amp; Latapy, 2005); effective for local structure; slower on &gt;10\u2074 nodes. Greedy Modularity Fast Coarse partitioning Optimizes modularity via agglomeration; very fast but suffers from resolution limit (Newman, 2004). Label Propagation Fast Quick heuristic Unsupervised label spreading; no objective function; non-deterministic and unstable (Raghavan et al., 2007). Spinglass Slow Small networks; theoretical interest Statistical mechanics approach (Reichardt &amp; Bornholdt, 2006); finds communities by simulating spin states; computationally intensive."},{"location":"4_clustering_statistics/#choosing-an-algorithm-quick-guidance","title":"Choosing an algorithm: quick guidance","text":"<ul> <li>For large networks (&gt;10\u2074 nodes): Louvain or Leiden (fast, scalable).</li> <li>For small, compact complexes: Markov Clustering (protein complexes, submodules).</li> <li>For hierarchical/local structure: Walktrap (medium size).</li> <li>For exploratory speed: Greedy or Label Propagation (but less precise).</li> <li>For research/theory on small graphs: Spinglass (rarely used in practice).</li> </ul>"},{"location":"4_clustering_statistics/#summary-of-statistical-methods","title":"Summary of Statistical Methods","text":"<p>RISK implements a suite of statistical tests\u2014ranging from fast approximations to rigorous overrepresentation analysis\u2014to assess functional term overrepresentation in network neighborhoods. Each method has strengths depending on dataset size, structure, and precision requirements.</p> Test Speed Primary use When/Why (assumptions &amp; notes) Permutation Medium Most rigorous; non-parametric Distribution-free empirical null (permute network or labels); preferred when assumptions are unclear; computationally intensive. Hypergeometric Medium Standard for GO/pathway overrepresentation Exact test for finite populations sampled without replacement; widely used for term\u2013to\u2013gene membership tables. Chi-squared Fast Approximate contingency-table testing Suitable for large samples with expected counts \u2265 5 per cell; fast but approximate; avoid with sparse/low counts. Binomial Fast Scalable approximation Fast approximation assuming independent trials/with-replacement; useful for large populations with small samples."},{"location":"4_clustering_statistics/#choosing-a-test-quick-guidance","title":"Choosing a test: quick guidance","text":"<ul> <li>For rigorous overrepresentation analysis with minimal assumptions: use Permutation or Hypergeometric.</li> <li>For large samples with many categories and sufficient counts: Chi-squared offers a fast approximate test.</li> <li>For speed and scalability with large populations and small samples: use Binomial as a practical approximation.</li> </ul>"},{"location":"4_clustering_statistics/#shared-parameters","title":"Shared Parameters","text":"<p>Shared parameters among statistical methods.</p> <ul> <li><code>network</code> (nx.Graph): The network graph.</li> <li><code>annotation</code> (dict): The annotation associated with the network.</li> <li><code>distance_metric</code> (str, list, tuple, or np.ndarray, optional): Method(s) used to compute distances for community detection. You can specify a single method or a list/tuple/array of methods to apply multiple community detection algorithms. Options include:<ul> <li><code>'louvain'</code>: Applies the Louvain method for community detection. (default)</li> <li><code>'greedy_modularity'</code>: Detects communities in a graph based on the greedy optimization of modularity.</li> <li><code>'label_propagation'</code>: Uses label propagation to find communities.</li> <li><code>'leiden'</code>: Applies the Leiden method for community detection.</li> <li><code>'markov_clustering'</code>: Implements the Markov Clustering Algorithm.</li> <li><code>'walktrap'</code>: Detects communities via random walks.</li> <li><code>'spinglass'</code>: Community detection based on the spinglass model.</li> </ul> </li> <li><code>louvain_resolution</code> (float, optional): Resolution parameter for the Louvain method. Only applies if <code>'louvain'</code> is one of the distance metrics. Defaults to 0.1.</li> <li><code>leiden_resolution</code> (float, optional): Resolution parameter for the Leiden method. Only applies if <code>'leiden'</code> is one of the distance metrics. Defaults to 1.0.</li> <li><code>fraction_shortest_edges</code> (float, list, tuple, or np.ndarray, optional): Shortest edge rank fraction threshold(s) for creating subgraphs. Can be a single float for one threshold or a list/tuple of floats corresponding to multiple thresholds. Defaults to 0.5.</li> <li><code>null_distribution</code> (str, optional): Defines the type of null distribution to use for comparison. Options include:<ul> <li><code>'network'</code>: Randomly permuted network structure. (default)</li> <li><code>'annotation'</code>: Randomly permuted annotations.</li> </ul> </li> <li><code>random_seed</code> (int, optional): Seed for random number generation in permutation test. Defaults to 888.</li> </ul>"},{"location":"4_clustering_statistics/#permutation-test","title":"Permutation Test","text":"<p>Builds an empirical null by permuting either the network structure or annotation labels.</p> <p>When to use:</p> <ul> <li>Non-parametric and distribution-free; ideal when analytical assumptions (independence, variance, distribution) are doubtful.</li> <li>Supports flexible nulls (permute network topology or term labels) to match study design.</li> <li>Most rigorous option but computationally intensive; prefer for smaller networks or final confirmation analyses.</li> </ul> <p>Additional Parameters:</p> <ul> <li><code>score_metric</code> (str, optional): Metric used to score neighborhoods. Options include: - <code>'sum'</code>: Sums the annotation values within each neighborhood. (default) - <code>'stdev'</code>: Computes the standard deviation of annotation values within each neighborhood.</li> <li><code>num_permutations</code> (int, optional): Number of permutations for significance testing. Defaults to 1000.</li> <li><code>max_workers</code> (int, optional): Maximum number of workers for parallel computation. Defaults to 1.</li> </ul> <p>Returns: <code>dict</code>: A dictionary containing the computed significance of neighborhoods within the network.</p> <pre><code>neighborhoods = risk.load_neighborhoods_permutation(\n    network=network,\n    annotation=annotation,\n    distance_metric=\"louvain\",\n    louvain_resolution=0.1,\n    fraction_shortest_edges=0.5,\n    score_metric=\"sum\",\n    null_distribution=\"network\",\n    num_permutations=1000,\n    random_seed=888,\n    max_workers=1,\n)\n</code></pre>"},{"location":"4_clustering_statistics/#hypergeometric-test","title":"Hypergeometric Test","text":"<p>Exact test based on finite sampling without replacement.</p> <p>When to use:</p> <ul> <li>Standard for GO/pathway overrepresentation with term\u2013to\u2013gene membership tables.</li> <li>Appropriate for finite populations sampled without replacement (e.g., selected cluster vs whole network).</li> <li>Exact test; more accurate than approximations when sample is not negligible relative to the population.</li> </ul> <p>Returns: <code>dict</code>: A dictionary containing the computed significance of neighborhoods within the network.</p> <pre><code>neighborhoods = risk.load_neighborhoods_hypergeom(\n    network=network,\n    annotation=annotation,\n    distance_metric=\"louvain\",\n    louvain_resolution=0.1,\n    fraction_shortest_edges=0.5,\n    null_distribution=\"network\",\n    random_seed=888,\n)\n</code></pre>"},{"location":"4_clustering_statistics/#chi-squared-test","title":"Chi-squared Test","text":"<p>Evaluates significance using contingency tables.</p> <p>When to use:</p> <ul> <li>Suitable for large-sample contingency analyses across multiple categories.</li> <li>Rule of thumb: expected counts per cell should be \u2265 5; avoid with sparse tables.</li> <li>Fast and scalable but approximate; consider permutation or exact tests for sparse data.</li> </ul> <p>Returns: <code>dict</code>: A dictionary containing the computed significance of neighborhoods within the network.</p> <pre><code>neighborhoods = risk.load_neighborhoods_chi2(\n    network=network,\n    annotation=annotation,\n    distance_metric=\"louvain\",\n    louvain_resolution=0.1,\n    fraction_shortest_edges=0.5,\n    null_distribution=\"network\",\n    random_seed=888,\n)\n</code></pre>"},{"location":"4_clustering_statistics/#binomial-test","title":"Binomial Test","text":"<p>Fast approximation to overrepresentation based on independent trials.</p> <p>When to use:</p> <ul> <li>Provides a scalable approximation to the hypergeometric test, assuming independent trials or sampling with replacement.</li> <li>Useful for very large populations with small samples where exact tests are computationally costly.</li> <li>Offers speed and scalability while being less precise than exact methods.</li> </ul> <p>Returns: <code>dict</code>: A dictionary containing the computed significance of neighborhoods within the network.</p> <pre><code>neighborhoods = risk.load_neighborhoods_binom(\n    network=network,\n    annotation=annotation,\n    distance_metric=\"louvain\",\n    louvain_resolution=0.1,\n    fraction_shortest_edges=0.5,\n    null_distribution=\"network\",\n    random_seed=888,\n)\n</code></pre>"},{"location":"4_clustering_statistics/#next-step","title":"Next Step","text":"<p>Building and Analyzing Networks</p>"},{"location":"5_analyzing_results/","title":"Building and Analyzing Results","text":"<p>The <code>NetworkGraph</code> object integrates network data, annotations, and overrepresentation results into a unified structure, supporting clustering, domain-level significance, and downstream visualization.</p>"},{"location":"5_analyzing_results/#create-a-networkgraph","title":"Create a <code>NetworkGraph</code>","text":"<p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): The network graph containing the nodes and edges to be analyzed.</li> <li><code>annotation</code> (dict): The annotation associated with the network, typically derived from biological or functional data.</li> <li><code>neighborhoods</code> (dict): The neighborhoods object, containing data from enrichment or depletion analysis.</li> <li><code>tail</code> (str, optional): Specifies the tail of the statistical test to use. Options include:<ul> <li><code>'right'</code>: For enrichment. (default)</li> <li><code>'left'</code>: For depletion.</li> <li><code>'both'</code>: For two-tailed analysis.</li> </ul> </li> <li><code>pval_cutoff</code> (float, optional): Cutoff value for p-values to determine significance. Range: Any value between 0 and 1. Defaults to 0.01.</li> <li><code>fdr_cutoff</code> (float, optional): Cutoff value for FDR-corrected p-values. Range: Any value between 0 and 1. Defaults to 0.9999.</li> <li><code>impute_depth</code> (int, optional): Depth for imputing missing values. Defaults to 1.</li> <li><code>prune_threshold</code> (float, optional): Threshold for pruning weak edges from the network graph. Range: Any value between 0 and 1. Defaults to 0.0.</li> <li><code>linkage_criterion</code> (str, optional): Criterion for clustering. Defaults to 'distance'. Options include:<ul> <li><code>'distance'</code>: Clusters are formed based on distance.</li> <li><code>'maxclust'</code>: Clusters are formed based on the maximum number of clusters.</li> <li><code>'off'</code>: Disables clustering; terms remain separate.</li> </ul> </li> <li><code>linkage_method</code> (str, optional): Method used for hierarchical clustering. Defaults to 'average'. Options include:<ul> <li><code>'auto'</code>: Automatically determines the optimal method using the silhouette score.</li> <li>Other options: <code>'single'</code>, <code>'complete'</code>, <code>'average'</code>, <code>'weighted'</code>, <code>'centroid'</code>, <code>'median'</code>, <code>'ward'</code>.</li> </ul> </li> <li><code>linkage_metric</code> (str, optional): Distance metric used for clustering. Defaults to 'yule'. Options include:<ul> <li><code>'auto'</code>: Automatically determines the optimal metric using the silhouette score.</li> <li>Other options: <code>'braycurtis'</code>, <code>'canberra'</code>, <code>'chebyshev'</code>, <code>'cityblock'</code>, <code>'correlation'</code>, <code>'cosine'</code>, <code>'dice'</code>, <code>'euclidean'</code>, <code>'hamming'</code>, <code>'jaccard'</code>, <code>'jensenshannon'</code>, <code>'kulczynski1'</code>, <code>'mahalanobis'</code>, <code>'matching'</code>, <code>'minkowski'</code>, <code>'rogerstanimoto'</code>, <code>'russellrao'</code>, <code>'seuclidean'</code>, <code>'sokalmichener'</code>, <code>'sokalsneath'</code>, <code>'sqeuclidean'</code>, <code>'yule'</code>.</li> </ul> </li> <li><code>linkage_threshold</code> (str or float, optional): The cutoff distance for forming flat clusters in hierarchical clustering. Accepts either a numeric threshold or <code>'auto'</code> to enable automatic threshold optimization using the silhouette score. Range depends on metric. Defaults to 0.2.</li> <li><code>min_cluster_size</code> (int, optional): Minimum size of clusters to be formed. Defaults to 5.</li> <li><code>max_cluster_size</code> (int, optional): Maximum size of clusters to be formed. Defaults to 1000.</li> </ul> <p>Returns: <code>NetworkGraph</code>: A <code>NetworkGraph</code> object representing the processed network, ready for analysis and visualization.</p> <pre><code>graph = risk.load_graph(\n    network=network,\n    annotation=annotation,\n    neighborhoods=neighborhoods,\n    tail=\"right\",\n    pval_cutoff=0.01,\n    fdr_cutoff=0.9999,\n    impute_depth=1,\n    prune_threshold=0.0,\n    linkage_criterion=\"distance\",\n    linkage_method=\"average\",\n    linkage_metric=\"yule\",\n    linkage_threshold=0.2,\n    min_cluster_size=5,\n    max_cluster_size=1000\n)\n</code></pre>"},{"location":"5_analyzing_results/#key-attributes","title":"Key Attributes","text":"<p>The <code>NetworkGraph</code> object exposes several mappings for cluster and node information:</p>"},{"location":"5_analyzing_results/#domain-level","title":"Domain-Level","text":"<ul> <li><code>domain_id_to_node_ids_map</code>: Maps each domain ID to the list of node IDs belonging to that domain.</li> <li><code>domain_id_to_node_labels_map</code>: Maps each domain ID to the list of node labels in that domain for readable visualization.</li> <li><code>domain_id_to_domain_terms_map</code>: Maps each domain ID to the list of enriched/significant terms associated with that domain.</li> <li><code>domain_id_to_domain_info_map</code>: Maps each domain ID to a metadata record (e.g., size, p-value, FDR, summary) about the domain.</li> </ul>"},{"location":"5_analyzing_results/#node-level","title":"Node-Level","text":"<ul> <li><code>node_id_to_node_label_map</code>: Maps each internal node ID to its display label.</li> <li><code>node_label_to_node_id_map</code>: Maps each display label back to its internal node ID.</li> <li><code>node_label_to_significance_map</code>: Maps each node label to its significance score from the analysis.</li> <li><code>node_significance_sums</code>: Array of aggregate significance values per node, used for sizing, coloring, or ranking.</li> </ul> <p>These attributes enable visualization, labeling, and export functionalities.</p>"},{"location":"5_analyzing_results/#summarize-results","title":"Summarize results","text":"<p>Inspect matched members, counts, and significance in a DataFrame.</p> <pre><code>summary_df = graph.summary.load()\nsummary_df.head()\n</code></pre>"},{"location":"5_analyzing_results/#export-summary","title":"Export Summary","text":"<p>Export the processed summary table in common formats for downstream use or sharing.</p> <p>Shared Parameters:</p> <p>Shared parameters among export methods.</p> <ul> <li><code>filepath</code> (str): The path where the file will be saved.</li> </ul> <pre><code>graph.summary.to_csv(\"./data/csv/summary/michaelis_2023.csv\")\ngraph.summary.to_json(\"./data/json/summary/michaelis_2023.json\")\ngraph.summary.to_txt(\"./data/txt/summary/michaelis_2023.txt\")\n</code></pre>"},{"location":"5_analyzing_results/#clean-domains","title":"Clean domains","text":"<p>Remove a domain (in-place) and retrieve its node labels:</p> <pre><code>domain_1_labels = graph.pop(1)\n</code></pre>"},{"location":"5_analyzing_results/#next-step","title":"Next Step","text":"<p>Visualizing Networks in RISK</p>"},{"location":"6_visualization/","title":"Visualizing Networks in RISK","text":"<p>Visualization highlights clusters within the network to make modular structure and functional associations easier to interpret. RISK provides a flexible and powerful plotting interface via the <code>NetworkPlotter</code> object. This enables generation of publication-ready figures with detailed domain annotations, significance-driven coloring, contours, and rich label customization.</p>"},{"location":"6_visualization/#create-a-networkplotter","title":"Create a <code>NetworkPlotter</code>","text":"<p>Load your <code>NetworkGraph</code> object into a <code>NetworkPlotter</code>.</p> <p>Parameters:</p> <ul> <li><code>graph</code> (NetworkGraph): The <code>NetworkGraph</code> object containing the network structure to be visualized.</li> <li><code>figsize</code> (tuple, optional): Size of the figure, specified as a tuple <code>(width, height)</code> in inches. Defaults to (10, 10).</li> <li><code>background_color</code> (str, list, tuple, or np.ndarray, optional): Background color of the plot. Provide a single color (e.g., <code>'white'</code>, <code>(1.0, 1.0, 1.0)</code> for RGB, or <code>(1.0, 1.0, 1.0, 1.0)</code> for RGBA). Defaults to 'white'.</li> <li><code>background_alpha</code> (float, None, optional): Transparency level of the background color. If provided, it overrides any existing alpha values found in <code>background_color</code>. Defaults to 1.0.</li> <li><code>pad</code> (float, optional): Padding value to adjust the axis limits around the network plot. Defaults to 0.3.</li> </ul> <p>Returns: <code>NetworkPlotter</code>: An instance of the plotter initialized with the provided graph and settings.</p> <pre><code>plotter = risk.load_plotter(\n    graph=graph,\n    figsize=(15, 15),\n    background_color=\"black\",\n    background_alpha=1.0,\n    pad=0.3,\n)\n</code></pre>"},{"location":"6_visualization/#plot_title","title":"plot_title()","text":"<p>Add a title and optional subtitle overlay.</p> <p>Parameters:</p> <ul> <li><code>title</code> (str, optional): Title of the plot. Defaults to None.</li> <li><code>subtitle</code> (str, optional): Subtitle of the plot. Defaults to None.</li> <li><code>title_fontsize</code> (int, optional): Font size for the title. Defaults to 20.</li> <li><code>subtitle_fontsize</code> (int, optional): Font size for the subtitle. Defaults to 14.</li> <li><code>font</code> (str, optional): Font family used for both the title and subtitle. Defaults to \"DejaVu Sans\".</li> <li><code>title_color</code> (str, list, tuple, or np.ndarray, optional): Color of the title text. Provide a single color (e.g., <code>\"black\"</code>, <code>(0.0, 0.0, 0.0)</code> for RGB, or <code>(0.0, 0.0, 0.0, 1.0)</code> for RGBA). Defaults to \"black\".</li> <li><code>title_color</code> (str, list, tuple, or np.ndarray, optional): Color of the subtitle text. Provide a single color (e.g., <code>\"black\"</code>, <code>(0.0, 0.0, 0.0)</code> for RGB, or <code>(0.0, 0.0, 0.0, 1.0)</code> for RGBA). Defaults to \"black\".</li> <li><code>title_x</code> (float, optional): X-axis position of the title. Defaults to 0.5.</li> <li><code>title_y</code> (float, optional): Y-axis position of the title. Defaults to 0.975.</li> <li><code>title_space_offset</code> (float, optional): Fraction of figure height to leave for the space above the plot. Defaults to 0.075.</li> <li><code>subtitle_offset</code> (float, optional): Offset factor to position the subtitle below the title. Defaults to 0.025.</li> </ul> <pre><code>plotter.plot_title(\n    title=\"Yeast PPI Network\",\n    subtitle=\"Michaelis et al., 2023\",\n    title_fontsize=24,\n    subtitle_fontsize=18,\n    font=\"Arial\",\n    title_color=\"white\",\n    subtitle_color=\"lightblue\",\n    title_x=0.5,\n    title_y=0.925,\n    title_space_offset=0.08,\n    subtitle_offset=0.025,\n)\n</code></pre>"},{"location":"6_visualization/#plot_circle_perimeter","title":"plot_circle_perimeter()","text":"<p>Draw a circular boundary around the network layout.</p> <p>Parameters:</p> <ul> <li><code>scale</code> (float, optional): Scaling factor for the perimeter's diameter. Defaults to 1.0.</li> <li><code>center_offset_x</code> (float, optional): Horizontal offset as a fraction of the diameter. Negative values shift the center left, positive values shift it right. Defaults to 0.0.</li> <li><code>center_offset_y</code> (float, optional): Vertical offset as a fraction of the diameter. Negative values shift the center down, positive values shift it up. Defaults to 0.0.</li> <li><code>linestyle</code> (str, optional): Line style for the circle. Options include <code>\"solid\"</code>, <code>\"dashed\"</code>, <code>\"dashdot\"</code>, <code>\"dotted\"</code>, or any Matplotlib-supported linestyle. Defaults to \"dashed\".</li> <li><code>linewidth</code> (float, optional): Width of the circle's outline. Defaults to 1.5.</li> <li><code>color</code> (str, list, tuple, or np.ndarray, optional): Color of the circle. Provide a single color (e.g., <code>\"black\"</code>, <code>(0.0, 0.0, 0.0)</code> for RGB, or <code>(0.0, 0.0, 0.0, 1.0)</code> for RGBA). Defaults to \"black\".</li> <li><code>outline_alpha</code> (float, None, optional): Transparency level for the circle's outline. If provided, it overrides any existing alpha values found in <code>color</code>. Defaults to 1.0.</li> <li><code>fill_alpha</code> (float, None, optional): Transparency level for the circle\u2019s fill. If provided, it overrides any existing alpha values found in <code>color</code>. Defaults to 0.0.</li> </ul> <pre><code>plotter.plot_circle_perimeter(\n    scale=1.02,\n    center_offset_x=0.0,\n    center_offset_y=0.0,\n    linestyle=\"solid\",\n    linewidth=1.5,\n    color=\"white\",\n    outline_alpha=1.0,\n    fill_alpha=0.0,\n)\n</code></pre> <p>For a more flexible contour-based layout boundary, see <code>plot_contour_perimeter()</code>.</p>"},{"location":"6_visualization/#plot_contour_perimeter","title":"plot_contour_perimeter()","text":"<p>Draw a contour boundary around the network layout.</p> <p>Parameters:</p> <ul> <li><code>scale</code> (float, optional): Scaling factor for the perimeter size. Defaults to 1.0.</li> <li><code>levels</code> (int, optional): Number of contour levels. Defaults to 3.</li> <li><code>bandwidth</code> (float, optional): Bandwidth for KDE, controlling the smoothness of the contour. Defaults to 0.8.</li> <li><code>grid_size</code> (int, optional): Resolution of the grid for KDE. Higher values create finer contours. Defaults to 250.</li> <li><code>color</code> (str, list, tuple, or np.ndarray, optional): Color of the circle. Provide a single color (e.g., <code>\"black\"</code>, <code>(0.0, 0.0, 0.0)</code> for RGB, or <code>(0.0, 0.0, 0.0, 1.0)</code> for RGBA). Defaults to \"black\".</li> <li><code>linestyle</code> (str, optional): Line style for the contour. Options include <code>\"solid\"</code>, <code>\"dashed\"</code>, <code>\"dashdot\"</code>, <code>\"dotted\"</code>, or any Matplotlib-supported linestyle. Defaults to \"solid\".</li> <li><code>linewidth</code> (float, optional): Width of the contour\u2019s outline. Defaults to 1.5.</li> <li><code>outline_alpha</code> (float, None, optional): Transparency level for the contour's outline. If provided, it overrides any existing alpha values found in <code>color</code>. Defaults to 1.0.</li> <li><code>fill_alpha</code> (float, None, optional): Transparency level for the contour\u2019s fill. If provided, it overrides any existing alpha values found in <code>color</code>. Defaults to 0.0.</li> </ul> <pre><code>plotter.plot_contour_perimeter(\n    levels=5,\n    bandwidth=0.8,\n    grid_size=250,\n    color=\"white\",\n    linestyle=\"solid\",\n    linewidth=2.0,\n    alpha=1.0,\n    fill_alpha=0.2,\n)\n</code></pre>"},{"location":"6_visualization/#plot_network","title":"plot_network()","text":"<p>Render nodes and edges with styles derived from significance-aware helpers.</p> <p>Parameters:</p> <ul> <li><code>node_size</code> (int or np.ndarray, optional): Size of the nodes. Can be a single integer or an array of sizes. Defaults to 50.</li> <li><code>node_shape</code> (str, optional): Shape of the nodes. Options include:<ul> <li><code>'o'</code>: Circle. (default)</li> <li><code>'s'</code>: Square.</li> <li><code>'^'</code>: Triangle up.</li> <li><code>'v'</code>: Triangle down.</li> <li>Other options: <code>'p'</code>, <code>'P'</code>, <code>'h'</code>, <code>'H'</code>, <code>'8'</code>, <code>'d'</code>, <code>'D'</code>, <code>'&gt;'</code>, <code>'&lt;</code>, <code>'|'</code>, <code>'_'</code>.</li> </ul> </li> <li><code>node_edgewidth</code> (float, optional): Width of the edges around each node. Defaults to 1.0.</li> <li><code>edge_width</code> (float, optional): Width of the edges in the plot. Defaults to 1.0.</li> <li><code>node_color</code> (str, list, tuple, or np.ndarray, optional): Color of the nodes. Can be a single color (e.g., <code>\"white\"</code>, <code>\"red\"</code>, <code>(0.5, 0.5, 0.5)</code> for RGB, or <code>(0.5, 0.5, 0.5, 0.8)</code> for RGBA) or an array of such colors. Defaults to \"white\".</li> <li><code>node_edgecolor</code> (str, list, tuple, or np.ndarray, optional): Color of the edges around each node. Can be a single color, a string of colors, or an array of string or RGB/RGBA colors. Defaults to \"black\".</li> <li><code>edge_color</code> (str, list, tuple, or np.ndarray, optional): Color of the edges connecting the nodes. Can be a single color, a string of colors, or an array of string or RGB/RGBA colors. Defaults to \"black\".</li> <li><code>node_alpha</code> (float or None, optional): Alpha value (transparency) for the nodes. Range: <code>0.0</code> (fully transparent) to 1.0<code>(fully opaque). If provided, it overrides any alpha values in</code>node_color`. Defaults to 1.0.</li> <li><code>edge_alpha</code> (float or None, optional): Alpha value (transparency) for the edges. Range: <code>0.0</code> (fully transparent) to 1.0<code>(fully opaque). If provided, it overrides any alpha values in</code>edge_color`. Defaults to 1.0.</li> </ul> <pre><code>plotter.plot_network(\n    node_size=node_sizes,\n    node_color=node_colors,\n    node_shape=\"o\",\n    node_edgewidth=1.0,\n    edge_width=0.03,\n    node_edgecolor=\"black\",\n    edge_color=\"white\",\n    node_alpha=1.0,\n    edge_alpha=1.0,\n)\n</code></pre>"},{"location":"6_visualization/#get_annotated_node_sizes","title":"get_annotated_node_sizes()","text":"<p>Generate node sizes based on annotation significance.</p> <p>Parameters:</p> <ul> <li><code>singificant_size</code> (int, optional): Size for singificant nodes. Defaults to 50.</li> <li><code>nonsignificant_size</code> (int, optional): Size for non-singificant nodes. Defaults to 25.</li> </ul> <p>Returns: <code>list</code>: List of node sizes corresponding to graph nodes.</p> <pre><code>node_sizes = plotter.get_annotated_node_sizes(\n    significant_size=225,\n    nonsignificant_size=12.5,\n)\n</code></pre>"},{"location":"6_visualization/#get_annotated_node_colors","title":"get_annotated_node_colors()","text":"<p>Generate node colors based on annotation significance and optional blending.</p> <p>Parameters:</p> <ul> <li><code>cmap</code> (str, optional): The colormap to use for node colors. Defaults to \"gist_rainbow\".</li> <li><code>color</code> (str, list, tuple, np.ndarray, or None, optional): A specific color to use for all nodes. Can be a single color (e.g., <code>\"red\"</code>, <code>(0.5, 0.5, 0.5)</code> for RGB, or <code>(0.5, 0.5, 0.5, 0.8)</code> for RGBA) or an array of such colors. If specified, this will override the colormap (<code>cmap</code>). Defaults to None.</li> <li><code>blend_colors</code> (bool, optional): Whether to blend colors for nodes with multiple domains. Defaults to False.</li> <li><code>blend_gamma</code> (float, optional): Gamma correction factor for perceptual color blending. Defaults to 2.2.</li> <li><code>min_scale</code> (float, optional): Minimum scale for color intensity. Defaults to 0.8.</li> <li><code>max_scale</code> (float, optional): Maximum scale for color intensity. Defaults to 1.0.</li> <li><code>scale_factor</code> (float, optional): Factor for adjusting the color scaling intensity. Defaults to 1.0.</li> <li><code>alpha</code> (float, None, optional): Alpha value for singificant nodes. If provided, it overrides any existing alpha values found in <code>color</code>. Defaults to 1.0.</li> <li><code>nonsignificant_color</code> (str, list, tuple, or np.ndarray, optional): Color for non-singificant nodes. Can be a single color (e.g., <code>\"white\"</code>, <code>(0.5, 0.5, 0.5)</code> for RGB, or <code>(0.5, 0.5, 0.5, 0.8)</code> for RGBA) or an array of such colors. Defaults to \"white\".</li> <li><code>nonsignificant_alpha</code> (float, None, optional): Alpha value for non-singificant nodes. If provided, it overrides any existing alpha values found in <code>nonsignificant_color</code>. Defaults to 1.0.</li> <li><code>ids_to_colors</code> (dict, None, optional): Mapping of domain IDs to specific colors. Defaults to None.</li> <li><code>random_seed</code> (int, optional): Seed for random number generation. Defaults to 888.</li> </ul> <p>Returns: <code>list</code>: List of colors for each node.</p> <pre><code>node_colors = plotter.get_annotated_node_colors(\n    cmap=\"gist_rainbow\",\n    color=None,\n    blend_colors=False,\n    blend_gamma=2.2,\n    min_scale=1.0,\n    max_scale=1.0,\n    scale_factor=0.5,\n    alpha=1.0,\n    nonsignificant_color=\"white\",\n    nonsignificant_alpha=0.75,\n    ids_to_colors=None,\n    random_seed=887,\n)\n</code></pre>"},{"location":"6_visualization/#plot_subnetwork","title":"plot_subnetwork()","text":"<p>Overlay a selected group of nodes and their connecting edges with distinct styling.</p> <p>Parameters:</p> <ul> <li><code>nodes</code> (list, tuple, or np.ndarray): List of node labels to include in the subnetwork. Accepts nested lists.</li> <li><code>node_size</code> (int or np.ndarray, optional): Size of the nodes. Can be a single integer or an array of sizes. Defaults to 50.</li> <li><code>node_shape</code> (str, optional): Shape of the nodes. Options include:<ul> <li><code>'o'</code>: Circle. (default)</li> <li><code>'s'</code>: Square.</li> <li><code>'^'</code>: Triangle up.</li> <li><code>'v'</code>: Triangle down.</li> <li>Other options: <code>'p'</code>, <code>'P'</code>, <code>'h'</code>, <code>'H'</code>, <code>'8'</code>, <code>'d'</code>, <code>'D'</code>, <code>'&gt;'</code>, <code>'&lt;</code>, <code>'|'</code>, <code>'_'</code>.</li> </ul> </li> <li><code>node_edgewidth</code> (float, optional): Width of the node edges. Defaults to 1.0.</li> <li><code>edge_width</code> (float, optional): Width of the edges in the subnetwork plot. Defaults to 1.0.</li> <li><code>node_color</code> (str, list, tuple, or np.ndarray, optional): Color of the nodes. Can be a single color (e.g., <code>\"red\"</code>, <code>(0.5, 0.5, 0.5)</code> for RGB, or <code>(0.5, 0.5, 0.5, 0.8)</code> for RGBA) or an array of such colors. Defaults to \"white\".</li> <li><code>node_edgecolor</code> (str, list, tuple, or np.ndarray, optional): Color of the node edges. Can be a single color or an array of string or RGB/RGBA colors. Defaults to \"black\".</li> <li><code>edge_color</code> (str, list, tuple, or np.ndarray, optional): Color of the edges connecting the nodes. Can be a single color or an array of string or RGB/RGBA colors. Defaults to \"black\".</li> <li><code>node_alpha</code> (float or None, optional): Transparency for the nodes. Range: <code>0.0</code> (fully transparent) to <code>1.0</code> (fully opaque). If provided, it overrides any alpha values in <code>node_color</code>. Defaults to None.</li> <li><code>edge_alpha</code> (float or None, optional): Transparency for the edges. Range: <code>0.0</code> (fully transparent) to <code>1.0</code> (fully opaque). If provided, it overrides any alpha values in <code>edge_color</code>. Defaults to None.</li> </ul> <pre><code>plotter.plot_subnetwork(\n    nodes=[\n        \"LSM1\", \"LSM2\", \"LSM3\", \"LSM4\", \"LSM5\", \"LSM6\", \"LSM7\", \"PAT1\",\n    ],\n    node_size=225,\n    node_shape=\"^\",\n    node_edgewidth=1.0,\n    edge_width=0.04,\n    node_color=\"white\",\n    node_edgecolor=\"black\",\n    edge_color=\"white\",\n    node_alpha=1.0,\n    edge_alpha=1.0,\n)\n</code></pre>"},{"location":"6_visualization/#plot_contours","title":"plot_contours()","text":"<p>Draw contours for domains (e.g., GO term regions).</p> <p>Parameters:</p> <ul> <li><code>levels</code> (int, optional): Number of contour levels to plot. Defaults to 5.</li> <li><code>bandwidth</code> (float, optional): Bandwidth for KDE, controlling the smoothness of the contour. Defaults to 0.8.</li> <li><code>grid_size</code> (int, optional): Resolution of the grid for KDE. Higher values create finer contours. Defaults to 250.</li> <li><code>color</code> (str, list, tuple, or np.ndarray, optional): Color of the contours. Can be a string (e.g., <code>\"white\"</code>), an RGB/RGBA value, or an array of such values. Defaults to \"white\".</li> <li><code>linestyle</code> (str, optional): Line style for the contours. Options include <code>'solid'</code>, <code>'dashed'</code>, <code>'dashdot'</code>, `'dotted'. Defaults to \"solid\".</li> <li><code>linewidth</code> (float, optional): Line width for the contours. Defaults to 1.5.</li> <li><code>alpha</code> (float, None, optional): Transparency level of the contour lines. Range: <code>0.0</code> (fully transparent) to <code>1.0</code> (fully opaque). If provided, it overrides any existing alpha values found in <code>color</code>. Defaults to 1.0.</li> <li><code>fill_alpha</code> (float, None, optional): Transparency level of the contour fill. If provided, it overrides any existing alpha values found in <code>color</code>. Defaults to None.</li> </ul> <pre><code>plotter.plot_contours(\n    levels=5,\n    bandwidth=0.8,\n    grid_size=250,\n    color=plotter.get_annotated_contour_colors(\n        cmap=\"gist_rainbow\",\n        color=None,\n        blend_colors=False,\n        blend_gamma=2.2,\n        min_scale=1.0,\n        max_scale=1.0,\n        scale_factor=0.5,\n        ids_to_colors=None,\n        random_seed=887,\n    ),\n    linestyle=\"solid\",\n    linewidth=2.0,\n    alpha=1.0,\n    fill_alpha=0.2,\n)\n</code></pre>"},{"location":"6_visualization/#get_annotated_contour_colors","title":"get_annotated_contour_colors()","text":"<p>Generate colors for domain contours based on annotation significance.</p> <p>Parameters:</p> <ul> <li><code>cmap</code> (str, optional): The colormap to use for contour colors. Defaults to \"gist_rainbow\".</li> <li><code>color</code> (str, list, tuple, np.ndarray, or None, optional): A specific color to use for all contours. Can be a string (e.g., <code>\"red\"</code>), an RGB or RGBA value, or an array of such values (strings, RGB, or RGBA). If specified, this will overwrite the colormap (<code>cmap</code>). Defaults to None.</li> <li><code>blend_colors</code> (bool, optional): Whether to blend colors for nodes with multiple domains. Defaults to False.</li> <li><code>blend_gamma</code> (float, optional): Gamma correction factor for perceptual color blending. Defaults to 2.2.</li> <li><code>min_scale</code> (float, optional): Minimum intensity scale for the colors generated by the colormap. Controls the dimmest colors. Defaults to 0.8.</li> <li><code>max_scale</code> (float, optional): Maximum intensity scale for the colors generated by the colormap. Controls the brightest colors. Defaults to 1.0.</li> <li><code>scale_factor</code> (float, optional): Exponent for adjusting color scaling based on significance scores. A higher value increases contrast by dimming lower scores more. Defaults to 1.0.</li> <li><code>ids_to_colors</code> (dict, None, optional): Mapping of domain IDs to specific colors. Defaults to None.</li> <li><code>random_seed</code> (int, optional): Seed for random number generation to ensure reproducibility. Defaults to 888.</li> </ul> <p>Returns: <code>list</code>: List of colors for each domain contour.</p> <pre><code>contour_colors = plotter.get_annotated_contour_colors(\n    cmap=\"gist_rainbow\",\n    color=None,\n    blend_colors=False,\n    blend_gamma=2.2,\n    min_scale=1.0,\n    max_scale=1.0,\n    scale_factor=0.5,\n    ids_to_colors=None,\n    random_seed=887,\n)\n</code></pre>"},{"location":"6_visualization/#plot_subcontour","title":"plot_subcontour()","text":"<p>Draw a contour around a subset of nodes.</p> <p>Parameters:</p> <ul> <li><code>nodes</code> (list, tuple, or np.ndarray): List of node labels or list of lists of node labels to plot the contour for.</li> <li><code>levels</code> (int, optional): Number of contour levels to plot. Defaults to 5.</li> <li><code>bandwidth</code> (float, optional): Bandwidth for KDE, controlling the smoothness of the contour. Defaults to 0.8.</li> <li><code>grid_size</code> (int, optional): Resolution of the grid for KDE. Higher values create finer contours. Defaults to 250.</li> <li><code>color</code> (str, list, tuple, or np.ndarray, optional): Color of the contour. Can be a string (e.g., <code>\"white\"</code>), an RGB or RGBA value, or an array of such values (strings, RGB, or RGBA). Defaults to \"white\".</li> <li><code>linestyle</code> (str, optional): Line style for the contour. Options include <code>'solid'</code>, <code>'dashed'</code>, <code>'dashdot'</code>, <code>'dotted'</code>. Defaults to \"solid\".</li> <li><code>linewidth</code> (float, optional): Line width for the contour. Defaults to 1.5.</li> <li><code>alpha</code> (float, None, optional): Transparency level of the contour lines. Range: <code>0.0</code> (fully transparent) to 1.0<code>(fully opaque). If provided, it overrides any existing alpha values found in</code>color`. Defaults to 1.0.</li> <li><code>fill_alpha</code> (float, None, optional): Transparency level of the contour fill. If provided, it overrides any existing alpha values found in <code>color</code>. Defaults to None.</li> </ul> <pre><code>plotter.plot_subcontour(\n    nodes=[\n        \"LSM1\", \"LSM2\", \"LSM3\", \"LSM4\", \"LSM5\", \"LSM6\", \"LSM7\", \"PAT1\",\n    ],\n    levels=5,\n    bandwidth=0.8,\n    grid_size=250,\n    color=\"white\",\n    linestyle=\"solid\",\n    linewidth=2.0,\n    alpha=1.0,\n    fill_alpha=0.25,\n)\n</code></pre>"},{"location":"6_visualization/#plot_labels","title":"plot_labels()","text":"<p>Annotate selected nodes or domains with styled text and arrows.</p> <p>Parameters:</p> <ul> <li><code>scale</code> (float, optional): Scale factor for positioning labels around the perimeter. Defaults to 1.05.</li> <li><code>offset</code> (float, optional): Offset distance for labels from the perimeter. Defaults to 0.10.</li> <li><code>font</code> (str, optional): Font name for the labels. Defaults to \"DejaVu Sans\".</li> <li><code>fontcase</code> (str, dict, or None, optional): Defines how to transform the case of words. Can be a string (<code>'upper'</code>, <code>'lower'</code>, <code>'title'</code>) or a dictionary mapping cases (e.g., <code>{'lower': 'title', 'upper': 'lower'}</code>). Defaults to None.</li> <li><code>fontsize</code> (int, optional): Font size for the labels. Defaults to 10.</li> <li><code>fontcolor</code> (str, list, tuple, or np.ndarray, optional): Color of the label text. Can be a string (e.g., <code>\"black\"</code>), an RGB or RGBA value, or an array of such values (strings, RGB, or RGBA). Defaults to \"black\".</li> <li><code>fontalpha</code> (float, None, optional): Transparency level for the font color. Range: <code>0.0</code> (fully transparent) to <code>1.0</code> (fully opaque). If provided, it overrides any existing alpha values found in <code>fontcolor</code>. Defaults to 1.0.</li> <li><code>arrow_linewidth</code> (float, optional): Line width of the arrows pointing to centroids. Defaults to 1.</li> <li><code>arrow_style</code> (str, optional): Style of the arrows pointing to centroids. Defaults to \"-&gt;\".</li> <li><code>arrow_color</code> (str, list, tuple, or np.ndarray, optional): Color of the arrows. Can be a string (e.g., <code>\"black\"</code>), an RGB or RGBA value, or an array of such values (strings, RGB, or RGBA). Defaults to \"black\".</li> <li><code>arrow_alpha</code> (float, None, optional): Transparency level for the arrow color. Range: <code>0.0</code> (fully transparent) to <code>1.0</code> (fully opaque). If provided, it overrides any existing alpha values found in <code>arrow_color</code>. Defaults to 1.0.</li> <li><code>arrow_base_shrink</code> (float, optional): Distance between the text and the base of the arrow. Defaults to 0.0.</li> <li><code>arrow_tip_shrink</code> (float, optional): Distance between the arrow tip and the centroid. Defaults to 0.0.</li> <li><code>max_labels</code> (int, optional): Maximum number of labels to plot. Defaults to None` (no limit.</li> <li><code>min_label_lines</code> (int, optional): Minimum number of lines in a label. Defaults to 1.</li> <li><code>max_label_lines</code> (int, optional): Maximum number of lines in a label. Defaults to None` (no limit.</li> <li><code>min_chars_per_line</code> (int, optional): Minimum number of characters in a line to display. Defaults to 1.</li> <li><code>max_chars_per_line</code> (int, optional): Maximum number of characters in a line to display. Defaults to None (no limit).</li> <li><code>words_to_omit</code> (list, optional): List of words to omit from the labels. Defaults to None.</li> <li><code>overlay_ids</code> (bool, optional): Whether to overlay domain IDs in the center of the centroids. Defaults to False.</li> <li><code>ids_to_keep</code> (list, tuple, np.ndarray, or None, optional): IDs of domains that must be labeled. To discover domain IDs, you can set <code>overlay_ids=True</code>. Defaults to None.</li> <li><code>ids_to_labels</code> (dict, optional): A dictionary mapping domain IDs to custom labels (strings). The labels should be space-separated words. If provided, the custom labels will replace the default domain terms. Defaults to None.</li> </ul> <pre><code>plotter.plot_labels(\n    scale=1.1,\n    offset=0.12,\n    font=\"Arial\",\n    fontcase={\"title\": \"lower\"},\n    fontsize=15,\n    fontcolor=\"white\",\n    fontalpha=1.0,\n    arrow_linewidth=2.0,\n    arrow_style=\"-\",\n    arrow_color=plotter.get_annotated_label_colors(\n        cmap=\"gist_rainbow\",\n        color=None,\n        blend_colors=False,\n        blend_gamma=2.2,\n        min_scale=1.0,\n        max_scale=1.0,\n        scale_factor=0.5,\n        ids_to_colors=None,\n        random_seed=887,\n    ),\n    arrow_alpha=1.0,\n    arrow_base_shrink=10.0,\n    arrow_tip_shrink=0.0,\n    max_labels=28,\n    min_label_lines=3,\n    max_label_lines=4,\n    min_chars_per_line=3,\n    max_chars_per_line=12,\n    words_to_omit=[\"from\", \"the\", \"into\", \"via\", \"novo\", \"process\", \"activity\"],\n    overlay_ids=False,\n    ids_to_keep=None,\n    ids_to_labels=None,\n)\n</code></pre>"},{"location":"6_visualization/#get_annotated_label_colors","title":"get_annotated_label_colors()","text":"<p>Generate colors for labels based on annotation significance.</p> <p>Parameters:</p> <ul> <li><code>cmap</code> (str, optional): The colormap to use for label colors. Defaults to \"gist_rainbow\".</li> <li><code>color</code> (str, list, tuple, np.ndarray, or None, optional): A specific color to use for all labels. Can be a string (e.g., <code>\"red\"</code>), an RGB or RGBA value, or an array of such values (strings, RGB, or RGBA). Warning: If specified, this will overwrite the colormap (<code>cmap</code>). Defaults to None.</li> <li><code>blend_colors</code> (bool, optional): Whether to blend colors for nodes with multiple domains. Defaults to False.</li> <li><code>blend_gamma</code> (float, optional): Gamma correction factor for perceptual color blending. Defaults to 2.2.</li> <li><code>min_scale</code> (float, optional): Minimum intensity scale for the colors generated by the colormap. Controls the dimmest colors. Defaults to 0.8.</li> <li><code>max_scale</code> (float, optional): Maximum intensity scale for the colors generated by the colormap. Controls the brightest colors. Defaults to 1.0.</li> <li><code>scale_factor</code> (float, optional): Exponent for adjusting color scaling based on significance scores. A higher value increases contrast by dimming lower scores more. Defaults to 1.0.</li> <li><code>ids_to_colors</code> (dict, None, optional): Mapping of domain IDs to specific colors. Defaults to None.</li> <li><code>random_seed</code> (int, optional): Seed for random number generation to ensure reproducibility. Defaults to 888.</li> </ul> <p>Returns: <code>list</code>: List of colors for each label.</p> <pre><code>label_colors = plotter.get_annotated_label_colors(\n    cmap=\"gist_rainbow\",\n    color=None,\n    blend_colors=False,\n    blend_gamma=2.2,\n    min_scale=1.0,\n    max_scale=1.0,\n    scale_factor=0.5,\n    ids_to_colors=None,\n    random_seed=887,\n)\n</code></pre>"},{"location":"6_visualization/#plot_sublabel","title":"plot_sublabel()","text":"<p>Add a single label tied to a chosen set of nodes (arrow points to centroid). Useful for naming complexes or pathway modules.</p> <p>Parameters:</p> <ul> <li><code>nodes</code> (list, tuple, or np.ndarray): List of node labels or list of lists of node labels to be used for calculating the centroid.</li> <li><code>label</code> (str): The label to be annotated on the network.</li> <li><code>radial_position</code> (float, optional): Radial angle for positioning the label around the network's perimeter. Range: <code>0-360</code> degrees. Defaults to 0.0.</li> <li><code>scale</code> (float, optional): Scale factor for positioning the label around the perimeter. Defaults to 1.05.</li> <li><code>offset</code> (float, optional): Offset distance for the label from the perimeter. Defaults to 0.10.</li> <li><code>font</code> (str, optional): Font name for the label. Defaults to \"DejaVu Sans\".<ul> <li>Options: Any valid font name (e.g., <code>\"DejaVu Sans\"</code>, <code>\"Times New Roman\"</code>).</li> </ul> </li> <li><code>fontsize</code> (int, optional): Font size for the label. Defaults to 10.<ul> <li>Options: Any integer value representing font size.</li> </ul> </li> <li><code>fontcolor</code> (str, list, tuple, or np.ndarray, optional): Color of the label text. Can be a string (e.g., <code>\"black\"</code>), an RGB or RGBA value, or an array of such values. Defaults to \"black\".</li> <li><code>fontalpha</code> (float, None, optional): Transparency level for the label font. Range: <code>0.0</code> (fully transparent) to <code>1.0</code> (fully opaque). If provided, it overrides any existing alpha values found in <code>fontcolor</code>. Defaults to 1.0.</li> <li><code>arrow_linewidth</code> (float, optional): Line width of the arrow pointing to the centroid. Defaults to 1.</li> <li><code>arrow_style</code> (str, optional): Style of the arrows pointing to the centroid. Defaults to \"-&gt;\".</li> <li><code>arrow_color</code> (str, list, tuple, or np.ndarray, optional): Color of the arrow. Can be a string, RGB/RGBA value, or an array of such values. Defaults to \"black\".</li> <li><code>arrow_alpha</code> (float, None, optional): Transparency level for the arrow. Range: <code>0.0</code> (fully transparent) to <code>1.0</code> (fully opaque). If provided, it overrides any existing alpha values found in <code>arrow_color</code>. Defaults to 1.0.</li> <li><code>arrow_base_shrink</code> (float, optional): Distance between the text and the base of the arrow. Defaults to 0.0.</li> <li><code>arrow_tip_shrink</code> (float, optional): Distance between the arrow tip and the centroid. Defaults to 0.0.</li> </ul> <pre><code>plotter.plot_sublabel(\n    nodes=[\n        \"LSM1\", \"LSM2\", \"LSM3\", \"LSM4\", \"LSM5\", \"LSM6\", \"LSM7\", \"PAT1\",\n    ],\n    label=\"LSM1-7-PAT1 Complex\",\n    radial_position=73,\n    scale=1.6,\n    offset=0.12,\n    font=\"Arial\",\n    fontsize=15,\n    fontcolor=\"white\",\n    fontalpha=1.0,\n    arrow_linewidth=2.0,\n    arrow_style=\"-\",\n    arrow_color=\"white\",\n    arrow_alpha=1.0,\n    arrow_base_shrink=10.0,\n    arrow_tip_shrink=0.0,\n)\n</code></pre>"},{"location":"6_visualization/#savefig","title":"savefig()","text":"<p>Save the current figure to file in formats like PNG, SVG, or PDF.</p> <p>Parameters:</p> <ul> <li><code>*args</code>: Positional arguments passed to <code>plt.savefig</code>. Commonly used for specifying the filename (e.g., <code>\"plot.png\"</code>).</li> <li><code>pad_inches</code> (float, optional): Padding around the figure when saving. Defaults to 0.5.</li> <li><code>dpi</code> (int, optional): Dots per inch (DPI) for the exported image. Defaults to 100.</li> <li><code>**kwargs</code>: Keyword arguments passed to <code>plt.savefig</code>, such as <code>format</code> (e.g., <code>\"png\"</code>, <code>\"pdf\"</code>) and other options like <code>bbox_inches</code>.</li> </ul> <pre><code>plotter.savefig(\"my_plot.png\", pad_inches=0.5, dpi=100)\n</code></pre>"},{"location":"6_visualization/#show","title":"show()","text":"<p>Display the current figure inline or in a graphical window.</p> <p>Parameters:</p> <ul> <li><code>*args</code>: Positional arguments passed to <code>plt.show</code>. Typically not used, but can be included for consistency.</li> <li><code>**kwargs</code>: Keyword arguments passed to <code>plt.show</code>, such as <code>block</code> to control whether the display blocks the execution of code.</li> </ul> <pre><code>plotter.show()\n</code></pre> <p></p>"},{"location":"6_visualization/#next-step","title":"Next Step","text":"<p>Overview of <code>risk.params</code></p>"},{"location":"7_parameters/","title":"Overview of <code>risk.params</code>","text":"<p>The <code>risk.params</code> module manages and exports analysis parameters, supporting inspection, saving, and sharing to improve reproducibility. Note: Reloading a RISK instance from a saved parameter file is not currently supported.</p>"},{"location":"7_parameters/#loading-parameters","title":"Loading Parameters","text":"<p>The <code>load()</code> method imports parameters from the running RISK instance. Any <code>np.ndarray</code> values are converted to lists for easier serialization.</p> <p>Returns: <code>dict</code>: A dictionary containing the processed parameters.</p> <pre><code>loaded_params = risk.params.load()\n</code></pre>"},{"location":"7_parameters/#exporting-parameters","title":"Exporting Parameters","text":"<p>Export RISK analysis parameters\u2014from network loading to visualization\u2014in common formats for downstream use or sharing.</p> <p>Shared Parameters:</p> <p>Shared parameters among export methods.</p> <ul> <li><code>filepath</code> (str): The path where the file will be saved.</li> </ul>"},{"location":"7_parameters/#export-to-csv","title":"Export to CSV","text":"<p>Exports the parameter dictionary to a <code>.csv</code> file.</p> <pre><code>risk.params.to_csv(filepath=\"./data/csv/params/michaelis_2023.csv\")\n</code></pre>"},{"location":"7_parameters/#export-to-json","title":"Export to JSON","text":"<p>Exports the parameter dictionary to a <code>.json</code> file. The hierarchical structure is preserved.</p> <pre><code>risk.params.to_json(filepath=\"./data/json/params/michaelis_2023.json\")\n</code></pre>"},{"location":"7_parameters/#export-to-text","title":"Export to Text","text":"<p>Exports the parameter dictionary to a plain <code>.txt</code> file in human\u2011readable format.</p> <pre><code>risk.params.to_txt(filepath=\"./data/txt/params/michaelis_2023.txt\")\n</code></pre> <p>These export functions allow parameters to be shared and archived. For downstream processing, combine them with summary exports from:</p> <ul> <li><code>graph.summary.to_csv()</code></li> <li><code>graph.summary.to_json()</code></li> <li><code>graph.summary.to_txt()</code></li> </ul> <p>For an interactive example showing how these parameters fit into a full RISK workflow, see tutorial.html or download the tutorial notebook and data. You can also launch the Quickstart notebook on Binder to explore the workflow without local installation.</p>"}]}