{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to RISK Network Documentation","text":"<p>RISK (Regional Inference of Significant Kinships) is a modular, scalable tool for biological network annotation and visualization. It integrates community detection, rigorous statistical testing, and high-resolution visualization in a single streamlined framework.</p> <p>These docs guide you through installation, usage, and advanced features.</p> <p></p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Begin here for setup and core concepts:</p> <ul> <li>0. Introduction: Overview of RISK and key principles</li> <li>1. Installation: Install RISK on your system</li> </ul> <p>Interactive tutorials:</p> <ul> <li>Launch Quickstart in Binder (no installation required)</li> <li>Full Tutorial (HTML)</li> <li>Download Tutorial + Data (ZIP)</li> </ul>"},{"location":"#core-features","title":"Core Features","text":"<ul> <li>2. Network Input</li> <li>3. Annotation</li> <li>4. Statistical Tests</li> <li>5. Loading and Analyzing Networks</li> <li>6. Visualization</li> <li>7. Parameter Management</li> </ul> <p>For interactive examples, use tutorial.zip in Jupyter or view the static HTML version.</p> <p>Contributions are welcome on GitHub. You can also explore the RISK source code.</p>"},{"location":"0_intro/","title":"Introduction to RISK","text":"<p>RISK (Regional Inference of Significant Kinships) is a next-generation tool for biological network annotation and visualization. It integrates community detection algorithms, statistically rigorous overrepresentation analysis, and high-resolution visualization to uncover structured relationships in complex networks.</p> <p>RISK is designed to:</p> <ul> <li>Identify biologically coherent modules in large-scale networks</li> <li>Perform fast and flexible overrepresentation testing</li> <li>Generate publication-ready visualizations</li> <li>Scale to networks with hundreds of thousands of edges on standard hardware</li> <li>Generalize beyond biology to interdisciplinary networks</li> </ul>"},{"location":"0_intro/#what-makes-risk-different","title":"What makes RISK different?","text":"Feature RISK Clustering Louvain, Leiden, Markov, Spinglass, etc. Statistics Permutation, hypergeometric, chi-squared, z, etc. File Formats NetworkX, Cytoscape (.cys, .cyjs), GPickle Annotation JSON, CSV, Excel, TSV, Python dict Scalability Networks with 500k+ edges on standard hardware Visual Output High-resolution SVG, PNG, PDF Beyond Biology Applied to a physics citation network (Supp. Fig. S7)"},{"location":"0_intro/#example-applications","title":"Example Applications","text":"<ul> <li>Functional module identification in yeast PPI and GI networks</li> <li>Pathway mapping for synthetic lethality analyses</li> <li>Drug\u2013target prediction via annotation overrepresentation</li> <li>Cross-domain network exploration in physics and other disciplines</li> </ul>"},{"location":"0_intro/#full-interactive-example","title":"Full Interactive Example","text":"<p>For a complete workflow, see tutorial.html, which demonstrates all key steps\u2014from loading a network to generating publication-ready figures\u2014in a single notebook. You can also download the notebook and data as a ZIP.</p> <p>The tutorial applies RISK to the Saccharomyces cerevisiae protein\u2013protein interaction (PPI) network (Michaelis et al., 2023; 3,839 nodes, 30,955 edges). It illustrates:</p> <ul> <li>Network clustering and module detection</li> <li>Annotation-based overrepresentation analysis</li> <li>Advanced visualization and interactive exploration</li> <li>Parameter export and reproducibility tools</li> </ul> <p>This notebook complements the Markdown documentation in this repository. Use it for end-to-end examples and contextual guidance.</p> <p>You can also launch the Quickstart notebook on Binder for an interactive session without local installation.</p>"},{"location":"0_intro/#getting-started","title":"Getting Started","text":"<p>Continue to 1. Installation to install RISK and set up your environment.</p>"},{"location":"1_installation/","title":"Installation","text":"<p>RISK is available on PyPI and supports Python 3.8 or later on major operating systems (Windows, macOS, Linux). Install the latest release with:</p> <pre><code>pip install risk-network --upgrade\n</code></pre> <p>To install from source:</p> <pre><code>git clone https://github.com/riskportal/network.git\ncd network\npip install .\n</code></pre>"},{"location":"1_installation/#importing-risk","title":"Importing RISK","text":"<p>Verify the installation and import the package:</p> <pre><code>import risk\nprint(risk.__version__)\n</code></pre> <p>The core functionality is accessed through the <code>RISK</code> class:</p> <pre><code>from risk import RISK\n</code></pre> <p>For Jupyter notebooks, enable inline plotting:</p> <pre><code>%matplotlib inline\n</code></pre>"},{"location":"1_installation/#initializing-risk","title":"Initializing RISK","text":"<p>Initialize a <code>RISK</code> object to start analysis:</p> <pre><code>risk = RISK(verbose=True)\n</code></pre> <ul> <li><code>verbose=True</code> enables console log messages.</li> <li>The object provides modular access to clustering, statistics, and visualization components.</li> </ul>"},{"location":"2_network_input/","title":"Loading Network for RISK Analysis","text":"<p>RISK offers flexible loading functions compatible with multiple network formats, including Cytoscape session files, Cytoscape JSON exports, GPickle files, and in-memory NetworkX graphs. These loaders provide standardized NetworkX graph objects ready for downstream analysis, with options for preprocessing such as spherical projection, surface depth adjustment, and node filtering.</p>"},{"location":"2_network_input/#supported-input-formats","title":"Supported Input Formats","text":"Format Function <code>.cys</code> <code>load_network_cytoscape()</code> <code>.cyjs</code> <code>load_network_cyjs()</code> <code>.gpickle</code> <code>load_network_gpickle()</code> <code>NetworkX</code> <code>load_network_networkx()</code> <p>All loaders accept shared preprocessing parameters for spherical projection, surface depth, and node filtering.</p>"},{"location":"2_network_input/#cytoscape-cys-files","title":"Cytoscape <code>.cys</code> Files","text":"<p>Load Cytoscape session files exported from the desktop app.</p> <p>Parameters:</p> <ul> <li><code>filepath</code> (str): Path to the <code>.cys</code> file.</li> <li><code>source_label</code> (str): Name of the source node attribute.</li> <li><code>target_label</code> (str): Name of the target node attribute.</li> <li><code>view_name</code> (str): Name of the Cytoscape view to load.</li> <li><code>compute_sphere</code> (bool, default=True): Apply 3D Mercator-inspired spherical projection.</li> <li><code>surface_depth</code> (float, default=0.0): Inward/outward displacement relative to sphere surface.</li> <li><code>min_edges_per_node</code> (int, default=0): Minimum degree threshold for nodes.</li> </ul> <p>Returns:</p> <p><code>nx.Graph</code>: The loaded and processed network as a NetworkX graph.</p> <pre><code>network = risk.load_network_cytoscape(\n    filepath=\"./data/cytoscape/michaelis_2023.cys\",\n    source_label=\"source\",\n    target_label=\"target\",\n    view_name=\"\",\n    compute_sphere=True,\n    surface_depth=0.0,\n    min_edges_per_node=0,\n)\n</code></pre>"},{"location":"2_network_input/#cytoscape-json-cyjs-files","title":"Cytoscape JSON (<code>.cyjs</code>) Files","text":"<p>Load JSON exports from Cytoscape Web or JavaScript pipelines.</p> <p>Parameters:</p> <ul> <li><code>filepath</code> (str): Path to the <code>.cyjs</code> file.</li> <li><code>source_label</code> (str): Name of the source node attribute.</li> <li><code>target_label</code> (str): Name of the target node attribute.</li> <li><code>compute_sphere</code> (bool, default=True): Apply 3D Mercator-inspired spherical projection.</li> <li><code>surface_depth</code> (float, default=0.0): Inward/outward displacement relative to sphere surface.</li> <li><code>min_edges_per_node</code> (int, default=0): Minimum degree threshold for nodes.</li> </ul> <p>Returns:</p> <p><code>nx.Graph</code>: The loaded and processed network as a NetworkX graph.</p> <pre><code>network = risk.load_network_cyjs(\n    filepath=\"./data/cyjs/michaelis_2023.cyjs\",\n    source_label=\"source\",\n    target_label=\"target\",\n    compute_sphere=True,\n    surface_depth=0.1,\n    min_edges_per_node=1,\n)\n</code></pre>"},{"location":"2_network_input/#gpickle-gpickle-files","title":"GPickle (<code>.gpickle</code>) Files","text":"<p>Fast, Python-native serialization of NetworkX graphs preserving all attributes. Recommended for reproducibility and performance.</p> <p>Parameters:</p> <ul> <li><code>filepath</code> (str): Path to the <code>.gpickle</code> file.</li> <li><code>compute_sphere</code> (bool, default=True): Apply 3D Mercator-inspired spherical projection.</li> <li><code>surface_depth</code> (float, default=0.0): Inward/outward displacement relative to sphere surface.</li> <li><code>min_edges_per_node</code> (int, default=0): Minimum degree threshold for nodes.</li> </ul> <p>Returns:</p> <p><code>nx.Graph</code>: The loaded and processed network as a NetworkX graph.</p> <pre><code>network = risk.load_network_gpickle(\n    filepath=\"./data/gpickle/michaelis_2023.gpickle\",\n    compute_sphere=True,\n    surface_depth=0.1,\n    min_edges_per_node=1,\n)\n</code></pre>"},{"location":"2_network_input/#networkx-graphs","title":"NetworkX Graphs","text":"<p>Load directly from an in-memory <code>networkx.Graph</code>. Integrates seamlessly when the graph is already loaded.</p> <p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): The input NetworkX graph.</li> <li><code>compute_sphere</code> (bool, default=True): Apply 3D Mercator-inspired spherical projection.</li> <li><code>surface_depth</code> (float, default=0.0): Inward/outward displacement relative to sphere surface.</li> <li><code>min_edges_per_node</code> (int, default=0): Minimum degree threshold for nodes.</li> </ul> <p>Returns:</p> <p><code>nx.Graph</code>: The loaded and processed network as a NetworkX graph.</p> <pre><code>network = risk.load_network_networkx(\n    network=network,\n    compute_sphere=True,\n    surface_depth=0.1,\n    min_edges_per_node=1,\n)\n</code></pre>"},{"location":"3_annotation/","title":"Loading and Associating Annotation Data","text":"<p>Annotations must be provided by the user and formatted clearly to ensure compatibility with RISK loaders. We note that RISK does not bundle annotations; users should obtain curated resources such as Gene Ontology (Ashburner et al., 2000), CORUM (Tsitsiridis et al., 2022), or KEGG (Kanehisa et al., 2023) and format them as term\u2013to\u2013gene membership tables. Publicly available resources such as Gene Ontology (GO), CORUM, and KEGG offer standardized annotation files that can be adapted for use.</p>"},{"location":"3_annotation/#supported-input-formats","title":"Supported Input Formats","text":"Format Function Example File <code>.json</code> <code>load_annotation_json()</code> <code>go_biological_process.json</code> <code>.csv</code> <code>load_annotation_csv()</code> <code>go_biological_process.csv</code> <code>.tsv</code> <code>load_annotation_tsv()</code> <code>go_biological_process.tsv</code> <code>.xlsx</code>/<code>.xls</code> <code>load_annotation_excel()</code> <code>go_biological_process.xlsx</code> <code>dict</code> <code>load_annotation_dict()</code> Python dictionary in memory <p>Annotations must be provided by the user and formatted clearly to ensure compatibility with RISK loaders. Publicly available resources such as Gene Ontology (GO), CORUM, and KEGG offer standardized annotation files that can be adapted for use.</p>"},{"location":"3_annotation/#json-annotation","title":"JSON Annotation","text":"<p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): Input NetworkX graph.</li> <li><code>filepath</code> (str): Path to the <code>.json</code> file.</li> <li><code>min_nodes_per_term</code> (int, default=1): Minimum number of nodes required for a term to be included.</li> <li><code>max_nodes_per_term</code> (int, default=10,000): Maximum number of nodes allowed for a term.</li> </ul> <p>Returns:</p> <p><code>dict</code>: A dictionary containing ordered nodes, ordered annotations, and the annotation matrix.</p> <pre><code>annotation = risk.load_annotation_json(\n    network=network,\n    filepath=\"./data/json/annotation/go_biological_process.json\",\n    min_nodes_per_term=1,\n    max_nodes_per_term=10_000,\n)\n</code></pre> <ul> <li>Loads GO BP annotations directly from JSON files.</li> <li>Annotations should follow the term\u2013to\u2013gene membership table format.</li> <li>Examples include GO BP terms, CORUM complexes, and KEGG pathways.</li> </ul>"},{"location":"3_annotation/#csv-annotation","title":"CSV Annotation","text":"<p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): Input NetworkX graph.</li> <li><code>filepath</code> (str): Path to the <code>.csv</code> file.</li> <li><code>label_colname</code> (str): Column name for annotation labels.</li> <li><code>nodes_colname</code> (str): Column name for nodes in the annotation.</li> <li><code>nodes_delimiter</code> (str, default=';'): Delimiter to split multiple nodes in a cell.</li> <li><code>min_nodes_per_term</code> (int, default=1): Minimum number of nodes required for a term to be included.</li> <li><code>max_nodes_per_term</code> (int, default=10,000): Maximum number of nodes allowed for a term.</li> </ul> <p>Returns:</p> <p><code>dict</code>: A dictionary containing ordered nodes, ordered annotations, and the annotation matrix.</p> <pre><code>annotation = risk.load_annotation_csv(\n    network=network,\n    filepath=\"./data/csv/annotation/go_biological_process.csv\",\n    label_colname=\"label\",\n    nodes_colname=\"nodes\",\n    nodes_delimiter=\";\",\n    min_nodes_per_term=1,\n    max_nodes_per_term=10_000,\n)\n</code></pre> <ul> <li>Loads annotation data from CSV files.</li> <li>Requires specifying column names for labels and nodes.</li> <li>Use <code>nodes_delimiter</code> to split multiple nodes per term (default = <code>;</code>).</li> <li>Annotations should follow the term\u2013to\u2013gene membership table format.</li> <li>Examples include GO BP terms, CORUM complexes, and KEGG pathways.</li> </ul>"},{"location":"3_annotation/#tsv-annotation","title":"TSV Annotation","text":"<p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): Input NetworkX graph.</li> <li><code>filepath</code> (str): Path to the <code>.tsv</code> file.</li> <li><code>label_colname</code> (str): Column name for annotation labels.</li> <li><code>nodes_colname</code> (str): Column name for nodes in the annotation.</li> <li><code>nodes_delimiter</code> (str, default=';'): Delimiter to split multiple nodes in a cell.</li> <li><code>min_nodes_per_term</code> (int, default=1): Minimum number of nodes required for a term to be included.</li> <li><code>max_nodes_per_term</code> (int, default=10,000): Maximum number of nodes allowed for a term.</li> </ul> <p>Returns:</p> <p><code>dict</code>: A dictionary containing ordered nodes, ordered annotations, and the annotation matrix.</p> <pre><code>annotation = risk.load_annotation_tsv(\n    network=network,\n    filepath=\"./data/tsv/annotation/go_biological_process.tsv\",\n    label_colname=\"label\",\n    nodes_colname=\"nodes\",\n    nodes_delimiter=\";\",\n    min_nodes_per_term=1,\n    max_nodes_per_term=10_000,\n)\n</code></pre> <ul> <li>Loads annotation data from TSV files.</li> <li>Same parameters as CSV loader, but expects tab-delimited input.</li> <li>Annotations should follow the term\u2013to\u2013gene membership table format.</li> <li>Examples include GO BP terms, CORUM complexes, and KEGG pathways.</li> </ul>"},{"location":"3_annotation/#excel-annotation","title":"Excel Annotation","text":"<p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): Input NetworkX graph.</li> <li><code>filepath</code> (str): Path to the Excel <code>.xlsx</code> or <code>.xls</code> file.</li> <li><code>label_colname</code> (str): Column name for annotation labels.</li> <li><code>nodes_colname</code> (str): Column name for nodes in the annotation.</li> <li><code>sheet_name</code> (str, default='Sheet1'): Name of the sheet to load.</li> <li><code>nodes_delimiter</code> (str, default=';'): Delimiter to split multiple nodes in a cell.</li> <li><code>min_nodes_per_term</code> (int, default=1): Minimum number of nodes required for a term to be included.</li> <li><code>max_nodes_per_term</code> (int, default=10,000): Maximum number of nodes allowed for a term.</li> </ul> <p>Returns:</p> <p><code>dict</code>: A dictionary containing ordered nodes, ordered annotations, and the annotation matrix.</p> <pre><code>annotation = risk.load_annotation_excel(\n    network=network,\n    filepath=\"./data/excel/annotation/go_biological_process.xlsx\",\n    label_colname=\"label\",\n    nodes_colname=\"nodes\",\n    sheet_name=\"Sheet1\",\n    nodes_delimiter=\";\",\n    min_nodes_per_term=1,\n    max_nodes_per_term=10_000,\n)\n</code></pre> <ul> <li>Loads annotation data from Excel workbooks.</li> <li>Allows loading from specific sheets.</li> <li>Annotations should follow the term\u2013to\u2013gene membership table format.</li> <li>Examples include GO BP terms, CORUM complexes, and KEGG pathways.</li> </ul>"},{"location":"3_annotation/#dictionary-based-annotation","title":"Dictionary-Based Annotation","text":"<p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): Input NetworkX graph.</li> <li><code>content</code> (dict): Python dictionary containing annotation data.</li> <li><code>min_nodes_per_term</code> (int, default=1): Minimum number of nodes required for a term to be included.</li> <li><code>max_nodes_per_term</code> (int, default=10,000): Maximum number of nodes allowed for a term.</li> </ul> <p>Returns:</p> <p><code>dict</code>: A dictionary containing ordered nodes, ordered annotations, and the annotation matrix.</p> <pre><code>import json\n\nwith open(\"./data/json/annotation/go_biological_process.json\") as file:\n    annotation_dict = json.load(file)\n\nannotation = risk.load_annotation_dict(\n    network=network,\n    content=annotation_dict,\n    min_nodes_per_term=1,\n    max_nodes_per_term=10_000,\n)\n</code></pre> <ul> <li>Loads annotation data from a Python dictionary in memory.</li> <li>Annotations should follow the term\u2013to\u2013gene membership table format.</li> <li>Examples include GO BP terms, CORUM complexes, and KEGG pathways.</li> </ul>"},{"location":"4_statistics/","title":"Statistical Tests for Annotation Significance","text":"<p>RISK implements multiple statistical methods to assess overrepresentation of functional terms in network neighborhoods. Each method has strengths depending on dataset size, structure, and precision requirements.</p>"},{"location":"4_statistics/#summary-of-methods","title":"Summary of Methods","text":"Test Speed Primary use When/Why (assumptions &amp; notes) Permutation Medium Most robust; non-parametric Distribution-free empirical null (permute network or labels); best when assumptions are unclear; computationally intensive. Hypergeometric Medium Standard for GO/pathway enrichment Finite population without replacement; exact count-based test for term\u2013to\u2013gene membership tables. Binomial Fast Scalable approximation With replacement/independent trials; good large-population approximation to hypergeometric when sample &lt;&lt; population. Chi-squared Fast Contingency-table testing, large samples For large counts; expected cell counts \u2265 5; very fast for big tables; avoid with sparse/low counts. Poisson Fast Rare events, sparse networks Counts of independent events at ~constant rate; good when events are rare (small p, large n). Check for overdispersion. Z-score Fast Quick standardized scoring Normal approximation; great for rapid ranking at scale; avoid when counts are very small or highly skewed."},{"location":"4_statistics/#choosing-a-test-quick-guidance","title":"Choosing a test: quick guidance","text":"<ul> <li>If assumptions are unclear / want a gold-standard null: use Permutation (robust, slower).</li> <li>Finite population without replacement (standard GO enrichment): use Hypergeometric.</li> <li>Need speed with large populations and small samples: use Binomial (approximation to hypergeometric).</li> <li>Many categories and large counts: use Chi-squared (fast), but ensure expected counts \u2265 5 per cell.</li> <li>Rare-event counts (sparse networks): use Poisson; verify that a constant-rate assumption is reasonable.</li> <li>Just need a fast ranking score (not exact p-values): use Z-score; treat results as heuristic when counts are small.</li> </ul>"},{"location":"4_statistics/#permutation-test","title":"Permutation Test","text":"<p>Builds an empirical null by permuting either the network structure or annotation labels.</p> <p>When to use:</p> <ul> <li>Non-parametric and distribution-free; ideal when analytical assumptions (independence, variance, distribution) are doubtful.</li> <li>Supports flexible nulls (permute network topology or term labels) to match study design.</li> <li>Most robust option but computationally intensive; prefer for smaller networks or final confirmation analyses.</li> </ul> <p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): The network graph.</li> <li><code>annotation</code> (dict): The annotation associated with the network.</li> <li><code>distance_metric</code> (str, list, tuple, or np.ndarray, optional): Methods for community detection, supporting <code>louvain</code>, <code>greedy_modularity</code>, <code>label_propagation</code>, <code>leiden</code>, <code>markov_clustering</code>, <code>walktrap</code>, <code>spinglass</code>.</li> <li><code>louvain_resolution</code> (float, optional): Resolution parameter for Louvain. Defaults to 0.1.</li> <li><code>leiden_resolution</code> (float, optional): Resolution parameter for Leiden. Defaults to 1.0.</li> <li><code>fraction_shortest_edges</code> (float, list, tuple, or np.ndarray, optional): Edge threshold(s) for subgraphs. Defaults to 0.5.</li> <li><code>score_metric</code> (str, optional): Scoring metric used in permutation tests; options include <code>\"sum\"</code> (default) and <code>\"stdev\"</code>.</li> <li><code>num_permutations</code> (int, optional): Number of permutations (only used in permutation test). Defaults to 1000.</li> <li><code>max_workers</code> (int, optional): Number of parallel workers for permutation tests. Defaults to 1.</li> <li><code>null_distribution</code> (str, optional): <code>\"network\"</code> (default) or <code>\"annotation\"</code>.</li> <li><code>random_seed</code> (int, optional): Seed for reproducibility.</li> </ul> <p>Returns:</p> <ul> <li><code>dict</code>: A dictionary containing the computed significance of neighborhoods within the network.</li> </ul> <pre><code>neighborhoods = risk.load_neighborhoods_permutation(\n    network=network,\n    annotation=annotation,\n    distance_metric=\"louvain\",\n    louvain_resolution=10.0,\n    leiden_resolution=1.0,\n    fraction_shortest_edges=0.225,\n    score_metric=\"stdev\",\n    null_distribution=\"network\",\n    num_permutations=1000,\n    random_seed=887,\n    max_workers=1,\n)\n</code></pre>"},{"location":"4_statistics/#hypergeometric-test","title":"Hypergeometric Test","text":"<p>Exact test based on finite sampling without replacement.</p> <p>When to use:</p> <ul> <li>Standard for GO/pathway overrepresentation with term\u2013to\u2013gene membership tables.</li> <li>Appropriate for finite populations sampled without replacement (e.g., selected cluster vs whole network).</li> <li>Exact test; more accurate than approximations when sample is not negligible relative to the population.</li> </ul> <p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): The network graph.</li> <li><code>annotation</code> (dict): The annotation associated with the network.</li> <li><code>distance_metric</code> (str, list, tuple, or np.ndarray, optional): Methods for community detection, supporting <code>louvain</code>, <code>greedy_modularity</code>, <code>label_propagation</code>, <code>leiden</code>, <code>markov_clustering</code>, <code>walktrap</code>, <code>spinglass</code>.</li> <li><code>louvain_resolution</code> (float, optional): Resolution parameter for Louvain. Defaults to 0.1.</li> <li><code>leiden_resolution</code> (float, optional): Resolution parameter for Leiden. Defaults to 1.0.</li> <li><code>fraction_shortest_edges</code> (float, list, tuple, or np.ndarray, optional): Edge threshold(s) for subgraphs. Defaults to 0.5.</li> <li><code>null_distribution</code> (str, optional): <code>\"network\"</code> (default) or <code>\"annotation\"</code>.</li> <li><code>random_seed</code> (int, optional): Seed for reproducibility.</li> </ul> <p>Returns:</p> <ul> <li><code>dict</code>: A dictionary containing the computed significance of neighborhoods within the network.</li> </ul> <pre><code>neighborhoods = risk.load_neighborhoods_hypergeom(\n    network=network,\n    annotation=annotation,\n    distance_metric=\"louvain\",\n    louvain_resolution=10.0,\n    leiden_resolution=1.0,\n    fraction_shortest_edges=0.225,\n    null_distribution=\"network\",\n    random_seed=887,\n)\n</code></pre>"},{"location":"4_statistics/#binomial-test","title":"Binomial Test","text":"<p>Approximates overrepresentation via independent trials.</p> <p>When to use:</p> <ul> <li>Fast approximation to hypergeometric when the population is large and the sample is small (sample &lt;&lt; population).</li> <li>Assumes independent trials / with-replacement sampling; use when this is reasonable or as a scalable proxy.</li> <li>Useful for very large networks where exact tests are costly.</li> </ul> <p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): The network graph.</li> <li><code>annotation</code> (dict): The annotation associated with the network.</li> <li><code>distance_metric</code> (str, list, tuple, or np.ndarray, optional): Methods for community detection, supporting <code>louvain</code>, <code>greedy_modularity</code>, <code>label_propagation</code>, <code>leiden</code>, <code>markov_clustering</code>, <code>walktrap</code>, <code>spinglass</code>.</li> <li><code>louvain_resolution</code> (float, optional): Resolution parameter for Louvain. Defaults to 0.1.</li> <li><code>leiden_resolution</code> (float, optional): Resolution parameter for Leiden. Defaults to 1.0.</li> <li><code>fraction_shortest_edges</code> (float, list, tuple, or np.ndarray, optional): Edge threshold(s) for subgraphs. Defaults to 0.5.</li> <li><code>null_distribution</code> (str, optional): <code>\"network\"</code> (default) or <code>\"annotation\"</code>.</li> <li><code>random_seed</code> (int, optional): Seed for reproducibility.</li> </ul> <p>Returns:</p> <ul> <li><code>dict</code>: A dictionary containing the computed significance of neighborhoods within the network.</li> </ul> <pre><code>neighborhoods = risk.load_neighborhoods_binom(\n    network=network,\n    annotation=annotation,\n    distance_metric=\"louvain\",\n    louvain_resolution=10.0,\n    leiden_resolution=1.0,\n    fraction_shortest_edges=0.225,\n    null_distribution=\"network\",\n    random_seed=887,\n)\n</code></pre>"},{"location":"4_statistics/#chi-squared-test","title":"Chi-squared Test","text":"<p>Evaluates significance using contingency tables.</p> <p>When to use:</p> <ul> <li>Best for large-sample contingency analyses across multiple categories.</li> <li>Rule of thumb: expected counts per cell should be \u2265 5; avoid with sparse tables (consider permutation or exact alternatives).</li> <li>Extremely fast and scalable for big matrices.</li> </ul> <p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): The network graph.</li> <li><code>annotation</code> (dict): The annotation associated with the network.</li> <li><code>distance_metric</code> (str, list, tuple, or np.ndarray, optional): Methods for community detection, supporting <code>louvain</code>, <code>greedy_modularity</code>, <code>label_propagation</code>, <code>leiden</code>, <code>markov_clustering</code>, <code>walktrap</code>, <code>spinglass</code>.</li> <li><code>louvain_resolution</code> (float, optional): Resolution parameter for Louvain. Defaults to 0.1.</li> <li><code>leiden_resolution</code> (float, optional): Resolution parameter for Leiden. Defaults to 1.0.</li> <li><code>fraction_shortest_edges</code> (float, list, tuple, or np.ndarray, optional): Edge threshold(s) for subgraphs. Defaults to 0.5.</li> <li><code>null_distribution</code> (str, optional): <code>\"network\"</code> (default) or <code>\"annotation\"</code>.</li> <li><code>random_seed</code> (int, optional): Seed for reproducibility.</li> </ul> <p>Returns:</p> <ul> <li><code>dict</code>: A dictionary containing the computed significance of neighborhoods within the network.</li> </ul> <pre><code>neighborhoods = risk.load_neighborhoods_chi2(\n    network=network,\n    annotation=annotation,\n    distance_metric=\"louvain\",\n    louvain_resolution=10.0,\n    leiden_resolution=1.0,\n    fraction_shortest_edges=0.225,\n    null_distribution=\"network\",\n    random_seed=887,\n)\n</code></pre>"},{"location":"4_statistics/#poisson-test","title":"Poisson Test","text":"<p>Tests observed frequencies against a Poisson expectation.</p> <p>When to use:</p> <ul> <li>Suitable for rare-event counts under an approximately constant rate; independence between events is assumed.</li> <li>Approximates binomial when event probability is small and the number of trials is large (small p, large n).</li> <li>Effective for sparse networks; check for overdispersion before use.</li> </ul> <p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): The network graph.</li> <li><code>annotation</code> (dict): The annotation associated with the network.</li> <li><code>distance_metric</code> (str, list, tuple, or np.ndarray, optional): Methods for community detection, supporting <code>louvain</code>, <code>greedy_modularity</code>, <code>label_propagation</code>, <code>leiden</code>, <code>markov_clustering</code>, <code>walktrap</code>, <code>spinglass</code>.</li> <li><code>louvain_resolution</code> (float, optional): Resolution parameter for Louvain. Defaults to 0.1.</li> <li><code>leiden_resolution</code> (float, optional): Resolution parameter for Leiden. Defaults to 1.0.</li> <li><code>fraction_shortest_edges</code> (float, list, tuple, or np.ndarray, optional): Edge threshold(s) for subgraphs. Defaults to 0.5.</li> <li><code>null_distribution</code> (str, optional): <code>\"network\"</code> (default) or <code>\"annotation\"</code>.</li> <li><code>random_seed</code> (int, optional): Seed for reproducibility.</li> </ul> <p>Returns:</p> <ul> <li><code>dict</code>: A dictionary containing the computed significance of neighborhoods within the network.</li> </ul> <pre><code>neighborhoods = risk.load_neighborhoods_poisson(\n    network=network,\n    annotation=annotation,\n    distance_metric=\"louvain\",\n    louvain_resolution=10.0,\n    leiden_resolution=1.0,\n    fraction_shortest_edges=0.225,\n    null_distribution=\"network\",\n    random_seed=887,\n)\n</code></pre>"},{"location":"4_statistics/#z-score-test","title":"Z-score Test","text":"<p>Computes standardized enrichment scores.</p> <p>When to use:</p> <ul> <li>Fastest option for large-scale screening and ranking.</li> <li>Relies on normal approximation (via CLT); works best with moderate-to-large counts.</li> <li>Treat as heuristic for very small counts or highly skewed distributions; confirm key findings with an exact or permutation test.</li> </ul> <p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): The network graph.</li> <li><code>annotation</code> (dict): The annotation associated with the network.</li> <li><code>distance_metric</code> (str, list, tuple, or np.ndarray, optional): Methods for community detection, supporting <code>louvain</code>, <code>greedy_modularity</code>, <code>label_propagation</code>, <code>leiden</code>, <code>markov_clustering</code>, <code>walktrap</code>, <code>spinglass</code>.</li> <li><code>louvain_resolution</code> (float, optional): Resolution parameter for Louvain. Defaults to 0.1.</li> <li><code>leiden_resolution</code> (float, optional): Resolution parameter for Leiden. Defaults to 1.0.</li> <li><code>fraction_shortest_edges</code> (float, list, tuple, or np.ndarray, optional): Edge threshold(s) for subgraphs. Defaults to 0.5.</li> <li><code>null_distribution</code> (str, optional): <code>\"network\"</code> (default) or <code>\"annotation\"</code>.</li> <li><code>random_seed</code> (int, optional): Seed for reproducibility.</li> </ul> <p>Returns:</p> <ul> <li><code>dict</code>: A dictionary containing the computed significance of neighborhoods within the network.</li> </ul> <pre><code>neighborhoods = risk.load_neighborhoods_zscore(\n    network=network,\n    annotation=annotation,\n    distance_metric=\"louvain\",\n    louvain_resolution=10.0,\n    leiden_resolution=1.0,\n    fraction_shortest_edges=0.225,\n    null_distribution=\"network\",\n    random_seed=887,\n)\n</code></pre>"},{"location":"5_load_graph/","title":"NetworkGraph Creation and Usage","text":"<p>The <code>NetworkGraph</code> object integrates network data, annotations, and overrepresentation results into a unified structure, supporting clustering, domain-level significance, and downstream visualization.</p>"},{"location":"5_load_graph/#create-a-networkgraph","title":"Create a <code>NetworkGraph</code>","text":"<p>Parameters:</p> <ul> <li><code>network</code> (nx.Graph): The network graph containing the nodes and edges to be analyzed.</li> <li><code>annotation</code> (dict): Annotation data associated with the network.</li> <li><code>neighborhoods</code> (dict): Neighborhood scores from enrichment/depletion analysis.</li> <li><code>tail</code> (str, optional): Specifies test tail. Options: <code>'right'</code> (default), <code>'left'</code>, <code>'both'</code>.</li> <li><code>pval_cutoff</code> (float, optional): Cutoff for raw p-values (0\u20131). Defaults to 0.01.</li> <li><code>fdr_cutoff</code> (float, optional): Cutoff for FDR-corrected p-values (0\u20131). Defaults to 0.9999.</li> <li><code>impute_depth</code> (int, optional): Depth for imputing missing values (\u22650). Defaults to 1.</li> <li><code>prune_threshold</code> (float, optional): Threshold for pruning weak edges (0\u20131). Defaults to 0.0.</li> <li><code>linkage_criterion</code> (str, optional): Criterion for clustering. Options: <code>'distance'</code> (default), <code>'maxclust'</code>, <code>'off'</code>.</li> <li><code>linkage_method</code> (str, optional): Hierarchical clustering method. Options: <code>'auto'</code>, <code>'single'</code>, <code>'complete'</code>, <code>'average'</code>, <code>'weighted'</code>, <code>'centroid'</code>, <code>'median'</code>, <code>'ward'</code>. Defaults to <code>'average'</code>.</li> <li><code>linkage_metric</code> (str, optional): Distance metric. Options: <code>'auto'</code>, <code>'braycurtis'</code>, <code>'canberra'</code>, <code>'chebyshev'</code>, <code>'cityblock'</code>, <code>'correlation'</code>, <code>'cosine'</code>, <code>'dice'</code>, <code>'euclidean'</code>, <code>'hamming'</code>, <code>'jaccard'</code>, <code>'jensenshannon'</code>, <code>'kulczynski1'</code>, <code>'mahalanobis'</code>, <code>'matching'</code>, <code>'minkowski'</code>, <code>'rogerstanimoto'</code>, <code>'russellrao'</code>, <code>'seuclidean'</code>, <code>'sokalmichener'</code>, <code>'sokalsneath'</code>, <code>'sqeuclidean'</code>, <code>'yule'</code>. Defaults to <code>'yule'</code>.</li> <li><code>linkage_threshold</code> (str or float, optional): Cutoff distance or <code>'auto'</code> for silhouette optimization. Defaults to 0.2.</li> <li><code>min_cluster_size</code> (int, optional): Minimum cluster size. Defaults to 5.</li> <li><code>max_cluster_size</code> (int, optional): Maximum cluster size. Defaults to 1000.</li> </ul> <p>Returns:</p> <ul> <li><code>NetworkGraph</code>: A <code>NetworkGraph</code> object representing the processed network, ready for analysis and visualization.</li> </ul> <pre><code>graph = risk.load_graph(\n    network=network,\n    annotation=annotation,\n    neighborhoods=neighborhoods,\n    tail=\"right\",\n    pval_cutoff=0.01,\n    fdr_cutoff=0.9999,\n    impute_depth=1,\n    prune_threshold=0.0,\n    linkage_criterion=\"distance\",\n    linkage_method=\"average\",\n    linkage_metric=\"yule\",\n    linkage_threshold=0.2,\n    min_cluster_size=5,\n    max_cluster_size=1000\n)\n</code></pre>"},{"location":"5_load_graph/#key-attributes","title":"Key Attributes","text":"<p>The <code>NetworkGraph</code> object exposes several mappings for cluster and node information:</p>"},{"location":"5_load_graph/#domain-level","title":"Domain-Level","text":"<ul> <li><code>domain_id_to_node_ids_map</code></li> <li><code>domain_id_to_node_labels_map</code></li> <li><code>domain_id_to_domain_terms_map</code></li> <li><code>domain_id_to_domain_info_map</code></li> </ul>"},{"location":"5_load_graph/#node-level","title":"Node-Level","text":"<ul> <li><code>node_id_to_node_label_map</code></li> <li><code>node_label_to_node_id_map</code></li> <li><code>node_label_to_significance_map</code></li> <li><code>node_significance_sums</code></li> </ul> <p>These attributes enable visualization, labeling, and export functionalities.</p>"},{"location":"5_load_graph/#example-workflow","title":"Example Workflow","text":""},{"location":"5_load_graph/#summarize-results","title":"Summarize results","text":"<pre><code>summary_df = graph.summary.load()\nsummary_df.head()\n</code></pre>"},{"location":"5_load_graph/#export-summary","title":"Export summary","text":"<pre><code>graph.summary.to_csv(\"./data/csv/summary/michaelis_2023.csv\")\ngraph.summary.to_json(\"./data/json/summary/michaelis_2023.json\")\ngraph.summary.to_txt(\"./data/txt/summary/michaelis_2023.txt\")\n</code></pre>"},{"location":"5_load_graph/#clean-domains","title":"Clean domains","text":"<p>Remove a domain and retrieve its node labels:</p> <pre><code>domain_1_labels = graph.pop(1)\n</code></pre>"},{"location":"6_visualization/","title":"Visualization","text":"<p>RISK provides a flexible and powerful plotting interface via the <code>NetworkPlotter</code> object. This enables generation of publication-ready figures with detailed domain annotations, significance-driven coloring, KDE-based contours, and rich label customization.</p>"},{"location":"6_visualization/#create-a-networkplotter","title":"Create a <code>NetworkPlotter</code>","text":"<p>You must first load your <code>NetworkGraph</code> object into a <code>NetworkPlotter</code>.</p> <p>Parameters:</p> <ul> <li><code>graph</code> (NetworkGraph): The network graph to visualize.</li> <li><code>figsize</code> (tuple, optional): Size of the figure in inches <code>(width, height)</code>. Default is <code>(10, 10)</code>.</li> <li><code>background_color</code> (str or tuple, optional): Background color of the plot. Default is <code>\"white\"</code>.</li> <li><code>background_alpha</code> (float, optional): Opacity of the plot background. Default is <code>1.0</code>.</li> <li><code>pad</code> (float, optional): Extra padding around the network layout. Default is <code>0.3</code>.</li> </ul> <p>Returns:</p> <ul> <li><code>NetworkPlotter</code>: An instance of the plotter initialized with the provided graph and settings.</li> </ul> <pre><code>plotter = risk.load_plotter(\n    graph=graph,\n    figsize=(15, 15),\n    background_color=\"black\",\n    background_alpha=1.0,\n    pad=0.3,\n)\n</code></pre>"},{"location":"6_visualization/#plot_title","title":"plot_title()","text":"<p>Add a title and optional subtitle overlay.</p> <p>Parameters:</p> <ul> <li><code>title</code> (str): Main title text.</li> <li><code>subtitle</code> (str, optional): Subtitle text.</li> <li><code>title_fontsize</code> (int, optional): Font size for the title.</li> <li><code>subtitle_fontsize</code> (int, optional): Font size for the subtitle.</li> <li><code>font</code> (str, optional): Font family.</li> <li><code>title_color</code> (str or tuple, optional): Color for the title text.</li> <li><code>subtitle_color</code> (str or tuple, optional): Color for the subtitle text.</li> <li><code>title_x</code> (float, optional): X-position of the title in figure coordinates.</li> <li><code>title_y</code> (float, optional): Y-position of the title in figure coordinates.</li> <li><code>title_space_offset</code> (float, optional): Vertical spacing offset for the title.</li> <li><code>subtitle_offset</code> (float, optional): Vertical spacing offset for the subtitle.</li> </ul> <pre><code>plotter.plot_title(\n    title=\"Yeast PPI Network\",\n    subtitle=\"Michaelis et al., 2023\",\n    title_fontsize=24,\n    subtitle_fontsize=18,\n    font=\"Arial\",\n    title_color=\"white\",\n    subtitle_color=\"lightblue\",\n    title_x=0.5,\n    title_y=0.925,\n    title_space_offset=0.08,\n    subtitle_offset=0.025,\n)\n</code></pre>"},{"location":"6_visualization/#plot_circle_perimeter","title":"plot_circle_perimeter()","text":"<p>Draw a circular boundary around the network layout.</p> <p>Parameters:</p> <ul> <li><code>scale</code> (float, optional): Scale factor for the circle size.</li> <li><code>center_offset_x</code> (float, optional): Horizontal offset of the circle center.</li> <li><code>center_offset_y</code> (float, optional): Vertical offset of the circle center.</li> <li><code>linestyle</code> (str, optional): Matplotlib line style string (e.g., <code>\"solid\"</code>, <code>\"dashed\"</code>).</li> <li><code>linewidth</code> (float, optional): Width of the circle boundary line.</li> <li><code>color</code> (str or tuple, optional): Color of the circle boundary.</li> <li><code>outline_alpha</code> (float, optional): Transparency of the circle outline.</li> <li><code>fill_alpha</code> (float, optional): Transparency of the circle fill.</li> </ul> <pre><code>plotter.plot_circle_perimeter(\n    scale=1.02,\n    center_offset_x=0.0,\n    center_offset_y=0.0,\n    linestyle=\"solid\",\n    linewidth=1.5,\n    color=\"white\",\n    outline_alpha=1.0,\n    fill_alpha=0.0,\n)\n</code></pre> <p>For a more flexible KDE-based layout boundary, see <code>plot_contour_perimeter()</code>.</p>"},{"location":"6_visualization/#plot_contour_perimeter","title":"plot_contour_perimeter()","text":"<p>Draw a KDE-based contour around the entire layout perimeter.</p> <p>Parameters:</p> <ul> <li><code>levels</code> (int, optional): Number of contour levels.</li> <li><code>bandwidth</code> (float, optional): Bandwidth parameter for KDE.</li> <li><code>grid_size</code> (int, optional): Resolution of the grid used for KDE.</li> <li><code>color</code> (str or tuple or list, optional): Color(s) for the contour lines.</li> <li><code>linestyle</code> (str, optional): Matplotlib line style string.</li> <li><code>linewidth</code> (float, optional): Width of the contour lines.</li> <li><code>alpha</code> (float, optional): Transparency of the contour lines.</li> <li><code>fill_alpha</code> (float, optional): Transparency of the filled contour areas.</li> </ul> <pre><code>plotter.plot_contour_perimeter(\n    levels=5,\n    bandwidth=0.8,\n    grid_size=250,\n    color=\"white\",\n    linestyle=\"solid\",\n    linewidth=2.0,\n    alpha=1.0,\n    fill_alpha=0.2,\n)\n</code></pre>"},{"location":"6_visualization/#plot_network","title":"plot_network()","text":"<p>Render nodes and edges with styles derived from significance-aware helpers.</p> <p>Parameters:</p> <ul> <li><code>node_size</code> (list or array, optional): Sizes for each node.</li> <li><code>node_color</code> (list or array or str, optional): Colors for each node.</li> <li><code>node_shape</code> (str, optional): Shape of the nodes (e.g., <code>\"o\"</code>).</li> <li><code>node_edgewidth</code> (float, optional): Width of the node borders.</li> <li><code>edge_width</code> (float, optional): Width of the edges.</li> <li><code>node_edgecolor</code> (str or tuple, optional): Color of the node borders.</li> <li><code>edge_color</code> (str or tuple, optional): Color of the edges.</li> <li><code>node_alpha</code> (float, optional): Transparency of nodes.</li> <li><code>edge_alpha</code> (float, optional): Transparency of edges.</li> </ul> <pre><code>plotter.plot_network(\n    node_size=node_sizes,\n    node_color=node_colors,\n    node_shape=\"o\",\n    node_edgewidth=1.0,\n    edge_width=0.03,\n    node_edgecolor=\"black\",\n    edge_color=\"white\",\n    node_alpha=1.0,\n    edge_alpha=1.0,\n)\n</code></pre>"},{"location":"6_visualization/#get_annotated_node_sizes","title":"get_annotated_node_sizes()","text":"<p>Generate node sizes based on annotation significance.</p> <p>Parameters:</p> <ul> <li><code>significant_size</code> (float, optional): Size for significant nodes.</li> <li><code>nonsignificant_size</code> (float, optional): Size for non-significant nodes.</li> </ul> <p>Returns:</p> <ul> <li><code>list</code>: List of node sizes corresponding to graph nodes.</li> </ul> <pre><code>node_sizes = plotter.get_annotated_node_sizes(\n    significant_size=225,\n    nonsignificant_size=12.5,\n)\n</code></pre>"},{"location":"6_visualization/#get_annotated_node_colors","title":"get_annotated_node_colors()","text":"<p>Generate node colors based on annotation significance and optional blending.</p> <p>Parameters:</p> <ul> <li><code>cmap</code> (str, optional): Colormap name. Default <code>\"gist_rainbow\"</code>.</li> <li><code>color</code> (str or tuple, optional): Base color.</li> <li><code>blend_colors</code> (bool, optional): Whether to blend colors.</li> <li><code>blend_gamma</code> (float, optional): Gamma correction for blending.</li> <li><code>min_scale</code> (float, optional): Minimum scale factor.</li> <li><code>max_scale</code> (float, optional): Maximum scale factor.</li> <li><code>scale_factor</code> (float, optional): Scaling applied to colors.</li> <li><code>alpha</code> (float, optional): Transparency.</li> <li><code>nonsignificant_color</code> (str or tuple, optional): Color for non-significant nodes.</li> <li><code>nonsignificant_alpha</code> (float, optional): Transparency for non-significant nodes.</li> <li><code>ids_to_colors</code> (dict, optional): Mapping from node IDs to colors.</li> <li><code>random_seed</code> (int, optional): Seed for reproducible color sampling.</li> </ul> <p>Returns:</p> <ul> <li><code>list</code>: List of colors for each node.</li> </ul> <pre><code>node_colors = plotter.get_annotated_node_colors(\n    cmap=\"gist_rainbow\",\n    color=None,\n    blend_colors=False,\n    blend_gamma=2.2,\n    min_scale=1.0,\n    max_scale=1.0,\n    scale_factor=0.5,\n    alpha=1.0,\n    nonsignificant_color=\"white\",\n    nonsignificant_alpha=0.75,\n    ids_to_colors=None,\n    random_seed=887,\n)\n</code></pre>"},{"location":"6_visualization/#plot_subnetwork","title":"plot_subnetwork()","text":"<p>Overlay a selected group of nodes and their connecting edges with distinct styling.</p> <p>Parameters:</p> <ul> <li><code>nodes</code> (list): List of node IDs to highlight.</li> <li><code>node_size</code> (float, optional): Size for the subnetwork nodes.</li> <li><code>node_shape</code> (str, optional): Shape of the subnetwork nodes.</li> <li><code>node_edgewidth</code> (float, optional): Width of the subnetwork node borders.</li> <li><code>edge_width</code> (float, optional): Width of the subnetwork edges.</li> <li><code>node_color</code> (str or tuple, optional): Color of the subnetwork nodes.</li> <li><code>node_edgecolor</code> (str or tuple, optional): Color of the subnetwork node borders.</li> <li><code>edge_color</code> (str or tuple, optional): Color of the subnetwork edges.</li> <li><code>node_alpha</code> (float, optional): Transparency of subnetwork nodes.</li> <li><code>edge_alpha</code> (float, optional): Transparency of subnetwork edges.</li> </ul> <pre><code>plotter.plot_subnetwork(\n    nodes=[\n        \"LSM1\", \"LSM2\", \"LSM3\", \"LSM4\", \"LSM5\", \"LSM6\", \"LSM7\", \"PAT1\",\n    ],\n    node_size=225,\n    node_shape=\"^\",\n    node_edgewidth=1.0,\n    edge_width=0.04,\n    node_color=\"white\",\n    node_edgecolor=\"black\",\n    edge_color=\"white\",\n    node_alpha=1.0,\n    edge_alpha=1.0,\n)\n</code></pre>"},{"location":"6_visualization/#plot_contours","title":"plot_contours()","text":"<p>Draw KDE contours for domains (e.g., GO term regions).</p> <p>Parameters:</p> <ul> <li><code>levels</code> (int, optional): Number of contour levels.</li> <li><code>bandwidth</code> (float, optional): Bandwidth parameter for KDE.</li> <li><code>grid_size</code> (int, optional): Resolution of the grid used for KDE.</li> <li><code>color</code> (list or str or tuple, optional): Colors for the contours.</li> <li><code>linestyle</code> (str, optional): Matplotlib line style string.</li> <li><code>linewidth</code> (float, optional): Width of the contour lines.</li> <li><code>alpha</code> (float, optional): Transparency of the contour lines.</li> <li><code>fill_alpha</code> (float, optional): Transparency of the filled contour areas.</li> </ul> <pre><code>plotter.plot_contours(\n    levels=5,\n    bandwidth=0.8,\n    grid_size=250,\n    color=plotter.get_annotated_contour_colors(\n        cmap=\"gist_rainbow\",\n        color=None,\n        blend_colors=False,\n        blend_gamma=2.2,\n        min_scale=1.0,\n        max_scale=1.0,\n        scale_factor=0.5,\n        ids_to_colors=None,\n        random_seed=887,\n    ),\n    linestyle=\"solid\",\n    linewidth=2.0,\n    alpha=1.0,\n    fill_alpha=0.2,\n)\n</code></pre>"},{"location":"6_visualization/#get_annotated_contour_colors","title":"get_annotated_contour_colors()","text":"<p>Generate colors for domain contours based on annotation significance.</p> <p>Parameters:</p> <ul> <li><code>cmap</code> (str, optional): Colormap name. Default <code>\"gist_rainbow\"</code>.</li> <li><code>color</code> (str or tuple, optional): Base color.</li> <li><code>blend_colors</code> (bool, optional): Whether to blend colors.</li> <li><code>blend_gamma</code> (float, optional): Gamma correction for blending.</li> <li><code>min_scale</code> (float, optional): Minimum scale factor.</li> <li><code>max_scale</code> (float, optional): Maximum scale factor.</li> <li><code>scale_factor</code> (float, optional): Scaling applied to colors.</li> <li><code>ids_to_colors</code> (dict, optional): Mapping from domain IDs to colors.</li> <li><code>random_seed</code> (int, optional): Seed for reproducible color sampling.</li> </ul> <p>Returns:</p> <ul> <li><code>list</code>: List of colors for each domain contour.</li> </ul> <pre><code>contour_colors = plotter.get_annotated_contour_colors(\n    cmap=\"gist_rainbow\",\n    color=None,\n    blend_colors=False,\n    blend_gamma=2.2,\n    min_scale=1.0,\n    max_scale=1.0,\n    scale_factor=0.5,\n    ids_to_colors=None,\n    random_seed=887,\n)\n</code></pre>"},{"location":"6_visualization/#plot_subcontour","title":"plot_subcontour()","text":"<p>Draw a KDE contour around a subset of nodes.</p> <p>Parameters:</p> <ul> <li><code>nodes</code> (list): List of node IDs to include in the contour.</li> <li><code>levels</code> (int, optional): Number of contour levels.</li> <li><code>bandwidth</code> (float, optional): Bandwidth parameter for KDE.</li> <li><code>grid_size</code> (int, optional): Resolution of the grid used for KDE.</li> <li><code>color</code> (str or tuple, optional): Color of the contour.</li> <li><code>linestyle</code> (str, optional): Matplotlib line style string.</li> <li><code>linewidth</code> (float, optional): Width of the contour lines.</li> <li><code>alpha</code> (float, optional): Transparency of the contour lines.</li> <li><code>fill_alpha</code> (float, optional): Transparency of the filled contour area.</li> </ul> <pre><code>plotter.plot_subcontour(\n    nodes=[\n        \"LSM1\", \"LSM2\", \"LSM3\", \"LSM4\", \"LSM5\", \"LSM6\", \"LSM7\", \"PAT1\",\n    ],\n    levels=5,\n    bandwidth=0.8,\n    grid_size=250,\n    color=\"white\",\n    linestyle=\"solid\",\n    linewidth=2.0,\n    alpha=1.0,\n    fill_alpha=0.25,\n)\n</code></pre>"},{"location":"6_visualization/#plot_labels","title":"plot_labels()","text":"<p>Annotate selected nodes or domains with styled text and arrows.</p> <p>Parameters:</p> <ul> <li><code>scale</code> (float, optional): Scaling factor for labels.</li> <li><code>offset</code> (float, optional): Offset distance for labels.</li> <li><code>font</code> (str, optional): Font family.</li> <li><code>fontcase</code> (dict, optional): Case transformations for titles.</li> <li><code>fontsize</code> (int, optional): Font size.</li> <li><code>fontcolor</code> (str or tuple, optional): Font color.</li> <li><code>fontalpha</code> (float, optional): Font transparency.</li> <li><code>arrow_linewidth</code> (float, optional): Width of arrow lines.</li> <li><code>arrow_style</code> (str, optional): Style of arrows.</li> <li><code>arrow_color</code> (list or str or tuple, optional): Colors for arrows.</li> <li><code>arrow_alpha</code> (float, optional): Transparency of arrows.</li> <li><code>arrow_base_shrink</code> (float, optional): Shrink length at arrow base.</li> <li><code>arrow_tip_shrink</code> (float, optional): Shrink length at arrow tip.</li> <li><code>max_labels</code> (int, optional): Maximum number of labels to display.</li> <li><code>min_label_lines</code> (int, optional): Minimum lines per label.</li> <li><code>max_label_lines</code> (int, optional): Maximum lines per label.</li> <li><code>min_chars_per_line</code> (int, optional): Minimum characters per line.</li> <li><code>max_chars_per_line</code> (int, optional): Maximum characters per line.</li> <li><code>words_to_omit</code> (list, optional): Words to omit from labels.</li> <li><code>overlay_ids</code> (bool, optional): Whether to overlay node IDs.</li> <li><code>ids_to_keep</code> (list, optional): List of node IDs to keep.</li> <li><code>ids_to_labels</code> (dict, optional): Mapping from node IDs to label strings.</li> </ul> <pre><code>plotter.plot_labels(\n    scale=1.1,\n    offset=0.12,\n    font=\"Arial\",\n    fontcase={\"title\": \"lower\"},\n    fontsize=15,\n    fontcolor=\"white\",\n    fontalpha=1.0,\n    arrow_linewidth=2.0,\n    arrow_style=\"-\",\n    arrow_color=plotter.get_annotated_label_colors(\n        cmap=\"gist_rainbow\",\n        color=None,\n        blend_colors=False,\n        blend_gamma=2.2,\n        min_scale=1.0,\n        max_scale=1.0,\n        scale_factor=0.5,\n        ids_to_colors=None,\n        random_seed=random_seed,\n    ),\n    arrow_alpha=1.0,\n    arrow_base_shrink=10.0,\n    arrow_tip_shrink=0.0,\n    max_labels=28,\n    min_label_lines=3,\n    max_label_lines=4,\n    min_chars_per_line=3,\n    max_chars_per_line=12,\n    words_to_omit=[\"from\", \"the\", \"into\", \"via\", \"novo\", \"process\", \"activity\"],\n    overlay_ids=False,\n    ids_to_keep=None,\n    ids_to_labels=None,\n)\n</code></pre>"},{"location":"6_visualization/#get_annotated_label_colors","title":"get_annotated_label_colors()","text":"<p>Generate colors for labels based on annotation significance.</p> <p>Parameters:</p> <ul> <li><code>cmap</code> (str, optional): Colormap name. Default <code>\"gist_rainbow\"</code>.</li> <li><code>color</code> (str or tuple, optional): Base color.</li> <li><code>blend_colors</code> (bool, optional): Whether to blend colors.</li> <li><code>blend_gamma</code> (float, optional): Gamma correction for blending.</li> <li><code>min_scale</code> (float, optional): Minimum scale factor.</li> <li><code>max_scale</code> (float, optional): Maximum scale factor.</li> <li><code>scale_factor</code> (float, optional): Scaling applied to colors.</li> <li><code>ids_to_colors</code> (dict, optional): Mapping from label IDs to colors.</li> <li><code>random_seed</code> (int, optional): Seed for reproducible color sampling.</li> </ul> <p>Returns:</p> <ul> <li><code>list</code>: List of colors for each label.</li> </ul> <pre><code>label_colors = plotter.get_annotated_label_colors(\n    cmap=\"gist_rainbow\",\n    color=None,\n    blend_colors=False,\n    blend_gamma=2.2,\n    min_scale=1.0,\n    max_scale=1.0,\n    scale_factor=0.5,\n    ids_to_colors=None,\n    random_seed=random_seed,\n)\n</code></pre>"},{"location":"6_visualization/#plot_sublabel","title":"plot_sublabel()","text":"<p>Add a single label tied to a chosen set of nodes (arrow points to centroid). Useful for naming complexes or pathway modules.</p> <p>Parameters:</p> <ul> <li><code>nodes</code> (list): List of node IDs to label.</li> <li><code>label</code> (str): Text label.</li> <li><code>radial_position</code> (float, optional): Radial position for label placement.</li> <li><code>scale</code> (float, optional): Scaling factor for the label.</li> <li><code>offset</code> (float, optional): Offset distance for the label.</li> <li><code>font</code> (str, optional): Font family.</li> <li><code>fontsize</code> (int, optional): Font size.</li> <li><code>fontcolor</code> (str or tuple, optional): Font color.</li> <li><code>fontalpha</code> (float, optional): Font transparency.</li> <li><code>arrow_linewidth</code> (float, optional): Width of arrow lines.</li> <li><code>arrow_style</code> (str, optional): Style of arrows.</li> <li><code>arrow_color</code> (str or tuple, optional): Color of the arrow.</li> <li><code>arrow_alpha</code> (float, optional): Transparency of the arrow.</li> <li><code>arrow_base_shrink</code> (float, optional): Shrink length at arrow base.</li> <li><code>arrow_tip_shrink</code> (float, optional): Shrink length at arrow tip.</li> </ul> <pre><code>plotter.plot_sublabel(\n    nodes=[\n        \"LSM1\", \"LSM2\", \"LSM3\", \"LSM4\", \"LSM5\", \"LSM6\", \"LSM7\", \"PAT1\",\n    ],\n    label=\"LSM1-7-PAT1 Complex\",\n    radial_position=73,\n    scale=1.6,\n    offset=0.12,\n    font=\"Arial\",\n    fontsize=15,\n    fontcolor=\"white\",\n    fontalpha=1.0,\n    arrow_linewidth=2.0,\n    arrow_style=\"-\",\n    arrow_color=\"white\",\n    arrow_alpha=1.0,\n    arrow_base_shrink=10.0,\n    arrow_tip_shrink=0.0,\n)\n</code></pre>"},{"location":"6_visualization/#savefig","title":"savefig()","text":"<p>Save the current figure to file in formats like PNG, SVG, or PDF.</p> <p>Parameters:</p> <ul> <li><code>filename</code> (str): Path and name of the output file.</li> </ul> <pre><code>plotter.savefig(\"my_plot.png\")\n</code></pre>"},{"location":"6_visualization/#show","title":"show()","text":"<p>Display the current figure inline or in a graphical window.</p> <p>Parameters:</p> <ul> <li>None</li> </ul> <pre><code>plotter.show()\n</code></pre> <p></p>"},{"location":"7_parameters/","title":"Overview of <code>risk.params</code>","text":"<p>The <code>risk.params</code> module in the RISK package is used to manage and export parameters related to your analysis. It lets you configure, save, and share the parameters used across the pipeline, improving reproducibility. Note: reloading a RISK instance from a saved parameter file is not currently supported.</p>"},{"location":"7_parameters/#loading-parameters","title":"Loading Parameters","text":"<p>The <code>load()</code> method imports parameters from the running RISK instance. Any <code>np.ndarray</code> values are converted to lists for easier serialization.</p> <p>Returns: <code>dict</code>: A dictionary containing the processed parameters.</p> <pre><code>loaded_params = risk.params.load()\n</code></pre>"},{"location":"7_parameters/#exporting-parameters","title":"Exporting Parameters","text":""},{"location":"7_parameters/#export-to-csv","title":"Export to CSV","text":"<p>Exports the parameter dictionary to a <code>.csv</code> file.</p> <p>Parameters:</p> <ul> <li><code>filepath</code> (str): The path where the CSV file will be saved.</li> </ul> <pre><code>risk.params.to_csv(filepath=\"./data/csv/params/michaelis_2023.csv\")\n</code></pre>"},{"location":"7_parameters/#export-to-json","title":"Export to JSON","text":"<p>Exports the parameter dictionary to a <code>.json</code> file. The hierarchical structure is preserved.</p> <p>Parameters:</p> <ul> <li><code>filepath</code> (str): The path where the JSON file will be saved.</li> </ul> <pre><code>risk.params.to_json(filepath=\"./data/json/params/michaelis_2023.json\")\n</code></pre>"},{"location":"7_parameters/#export-to-text","title":"Export to Text","text":"<p>Exports the parameter dictionary to a formatted <code>.txt</code> file.</p> <p>Parameters:</p> <ul> <li><code>filepath</code> (str): The path where the text file will be saved.</li> </ul> <pre><code>risk.params.to_txt(filepath=\"./data/txt/params/michaelis_2023.txt\")\n</code></pre> <p>These export functions allow parameters to be shared and archived. For downstream processing, combine them with summary exports from:</p> <ul> <li><code>graph.summary.to_csv()</code></li> <li><code>graph.summary.to_json()</code></li> <li><code>graph.summary.to_txt()</code></li> </ul> <p>For an interactive example showing how these parameters fit into a full RISK workflow, see tutorial.html or download the tutorial notebook and data. You can also launch the Quickstart notebook on Binder to explore the workflow without local installation.</p>"}]}